{
  "type": "module",
  "source": "doc/api/module.md",
  "modules": [
    {
      "textRaw": "Modules: `node:module` API",
      "name": "modules:_`node:module`_api",
      "introduced_in": "v12.20.0",
      "meta": {
        "added": [
          "v0.3.7"
        ],
        "changes": []
      },
      "modules": [
        {
          "textRaw": "The `Module` object",
          "name": "the_`module`_object",
          "desc": "<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\" class=\"type\">&lt;Object&gt;</a></li>\n</ul>\n<p>Provides general utility methods when interacting with instances of\n<code>Module</code>, the <a href=\"#the-module-object\"><code>module</code></a> variable often seen in <a href=\"modules.html\">CommonJS</a> modules. Accessed\nvia <code>import 'node:module'</code> or <code>require('node:module')</code>.</p>",
          "properties": [
            {
              "textRaw": "`builtinModules` {string\\[]}",
              "type": "string\\[]",
              "name": "builtinModules",
              "meta": {
                "added": [
                  "v9.3.0",
                  "v8.10.0",
                  "v6.13.0"
                ],
                "changes": [
                  {
                    "version": "v23.5.0",
                    "pr-url": "https://github.com/nodejs/node/pull/56185",
                    "description": "The list now also contains prefix-only modules."
                  }
                ]
              },
              "desc": "<p>A list of the names of all modules provided by Node.js. Can be used to verify\nif a module is maintained by a third party or not.</p>\n<p><code>module</code> in this context isn't the same object that's provided\nby the <a href=\"modules.html#the-module-wrapper\">module wrapper</a>. To access it, require the <code>Module</code> module:</p>\n<pre><code class=\"language-mjs\">// module.mjs\n// In an ECMAScript module\nimport { builtinModules as builtin } from 'node:module';\n</code></pre>\n<pre><code class=\"language-cjs\">// module.cjs\n// In a CommonJS module\nconst builtin = require('node:module').builtinModules;\n</code></pre>"
            }
          ],
          "methods": [
            {
              "textRaw": "`module.createRequire(filename)`",
              "type": "method",
              "name": "createRequire",
              "meta": {
                "added": [
                  "v12.2.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {require} Require function",
                    "name": "return",
                    "type": "require",
                    "desc": "Require function"
                  },
                  "params": [
                    {
                      "textRaw": "`filename` {string|URL} Filename to be used to construct the require function. Must be a file URL object, file URL string, or absolute path string.",
                      "name": "filename",
                      "type": "string|URL",
                      "desc": "Filename to be used to construct the require function. Must be a file URL object, file URL string, or absolute path string."
                    }
                  ]
                }
              ],
              "desc": "<pre><code class=\"language-mjs\">import { createRequire } from 'node:module';\nconst require = createRequire(import.meta.url);\n\n// sibling-module.js is a CommonJS module.\nconst siblingModule = require('./sibling-module');\n</code></pre>"
            },
            {
              "textRaw": "`module.findPackageJSON(specifier[, base])`",
              "type": "method",
              "name": "findPackageJSON",
              "meta": {
                "added": [
                  "v23.2.0"
                ],
                "changes": []
              },
              "stability": 1,
              "stabilityText": ".1 - Active Development",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {string|undefined} A path if the `package.json` is found. When `specifier` is a package, the package's root `package.json`; when a relative or unresolved, the closest `package.json` to the `specifier`.",
                    "name": "return",
                    "type": "string|undefined",
                    "desc": "A path if the `package.json` is found. When `specifier` is a package, the package's root `package.json`; when a relative or unresolved, the closest `package.json` to the `specifier`."
                  },
                  "params": [
                    {
                      "textRaw": "`specifier` {string|URL} The specifier for the module whose `package.json` to retrieve. When passing a _bare specifier_, the `package.json` at the root of the package is returned. When passing a _relative specifier_ or an _absolute specifier_, the closest parent `package.json` is returned.",
                      "name": "specifier",
                      "type": "string|URL",
                      "desc": "The specifier for the module whose `package.json` to retrieve. When passing a _bare specifier_, the `package.json` at the root of the package is returned. When passing a _relative specifier_ or an _absolute specifier_, the closest parent `package.json` is returned."
                    },
                    {
                      "textRaw": "`base` {string|URL} The absolute location (`file:` URL string or FS path) of the containing module. For CJS, use `__filename` (not `__dirname`!); for ESM, use `import.meta.url`. You do not need to pass it if `specifier` is an `absolute specifier`.",
                      "name": "base",
                      "type": "string|URL",
                      "desc": "The absolute location (`file:` URL string or FS path) of the containing module. For CJS, use `__filename` (not `__dirname`!); for ESM, use `import.meta.url`. You do not need to pass it if `specifier` is an `absolute specifier`."
                    }
                  ]
                }
              ],
              "desc": "<blockquote>\n<p><strong>Caveat</strong>: Do not use this to try to determine module format. There are many things affecting\nthat determination; the <code>type</code> field of package.json is the <em>least</em> definitive (ex file extension\nsupersedes it, and a loader hook supersedes that).</p>\n</blockquote>\n<blockquote>\n<p><strong>Caveat</strong>: This currently leverages only the built-in default resolver; if\n<a href=\"#resolvespecifier-context-nextresolve\"><code>resolve</code> customization hooks</a> are registered, they will not affect the resolution.\nThis may change in the future.</p>\n</blockquote>\n<pre><code class=\"language-text\">/path/to/project\n  ├ packages/\n    ├ bar/\n      ├ bar.js\n      └ package.json // name = '@foo/bar'\n    └ qux/\n      ├ node_modules/\n        └ some-package/\n          └ package.json // name = 'some-package'\n      ├ qux.js\n      └ package.json // name = '@foo/qux'\n  ├ main.js\n  └ package.json // name = '@foo'\n</code></pre>\n<pre><code class=\"language-mjs\">// /path/to/project/packages/bar/bar.js\nimport { findPackageJSON } from 'node:module';\n\nfindPackageJSON('..', import.meta.url);\n// '/path/to/project/package.json'\n// Same result when passing an absolute specifier instead:\nfindPackageJSON(new URL('../', import.meta.url));\nfindPackageJSON(import.meta.resolve('../'));\n\nfindPackageJSON('some-package', import.meta.url);\n// '/path/to/project/packages/bar/node_modules/some-package/package.json'\n// When passing an absolute specifier, you might get a different result if the\n// resolved module is inside a subfolder that has nested `package.json`.\nfindPackageJSON(import.meta.resolve('some-package'));\n// '/path/to/project/packages/bar/node_modules/some-package/some-subfolder/package.json'\n\nfindPackageJSON('@foo/qux', import.meta.url);\n// '/path/to/project/packages/qux/package.json'\n</code></pre>\n<pre><code class=\"language-cjs\">// /path/to/project/packages/bar/bar.js\nconst { findPackageJSON } = require('node:module');\nconst { pathToFileURL } = require('node:url');\nconst path = require('node:path');\n\nfindPackageJSON('..', __filename);\n// '/path/to/project/package.json'\n// Same result when passing an absolute specifier instead:\nfindPackageJSON(pathToFileURL(path.join(__dirname, '..')));\n\nfindPackageJSON('some-package', __filename);\n// '/path/to/project/packages/bar/node_modules/some-package/package.json'\n// When passing an absolute specifier, you might get a different result if the\n// resolved module is inside a subfolder that has nested `package.json`.\nfindPackageJSON(pathToFileURL(require.resolve('some-package')));\n// '/path/to/project/packages/bar/node_modules/some-package/some-subfolder/package.json'\n\nfindPackageJSON('@foo/qux', __filename);\n// '/path/to/project/packages/qux/package.json'\n</code></pre>"
            },
            {
              "textRaw": "`module.isBuiltin(moduleName)`",
              "type": "method",
              "name": "isBuiltin",
              "meta": {
                "added": [
                  "v18.6.0",
                  "v16.17.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} returns true if the module is builtin else returns false",
                    "name": "return",
                    "type": "boolean",
                    "desc": "returns true if the module is builtin else returns false"
                  },
                  "params": [
                    {
                      "textRaw": "`moduleName` {string} name of the module",
                      "name": "moduleName",
                      "type": "string",
                      "desc": "name of the module"
                    }
                  ]
                }
              ],
              "desc": "<pre><code class=\"language-mjs\">import { isBuiltin } from 'node:module';\nisBuiltin('node:fs'); // true\nisBuiltin('fs'); // true\nisBuiltin('wss'); // false\n</code></pre>"
            },
            {
              "textRaw": "`module.register(specifier[, parentURL][, options])`",
              "type": "method",
              "name": "register",
              "meta": {
                "added": [
                  "v20.6.0",
                  "v18.19.0"
                ],
                "changes": [
                  {
                    "version": "v23.6.1",
                    "pr-url": "https://github.com/nodejs-private/node-private/pull/629",
                    "description": "Using this feature with the permission model enabled requires passing `--allow-worker`."
                  },
                  {
                    "version": [
                      "v20.8.0",
                      "v18.19.0"
                    ],
                    "pr-url": "https://github.com/nodejs/node/pull/49655",
                    "description": "Add support for WHATWG URL instances."
                  }
                ]
              },
              "stability": 1,
              "stabilityText": ".2 - Release candidate",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`specifier` {string|URL} Customization hooks to be registered; this should be the same string that would be passed to `import()`, except that if it is relative, it is resolved relative to `parentURL`.",
                      "name": "specifier",
                      "type": "string|URL",
                      "desc": "Customization hooks to be registered; this should be the same string that would be passed to `import()`, except that if it is relative, it is resolved relative to `parentURL`."
                    },
                    {
                      "textRaw": "`parentURL` {string|URL} If you want to resolve `specifier` relative to a base URL, such as `import.meta.url`, you can pass that URL here. **Default:** `'data:'`",
                      "name": "parentURL",
                      "type": "string|URL",
                      "default": "`'data:'`",
                      "desc": "If you want to resolve `specifier` relative to a base URL, such as `import.meta.url`, you can pass that URL here."
                    },
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`parentURL` {string|URL} If you want to resolve `specifier` relative to a base URL, such as `import.meta.url`, you can pass that URL here. This property is ignored if the `parentURL` is supplied as the second argument. **Default:** `'data:'`",
                          "name": "parentURL",
                          "type": "string|URL",
                          "default": "`'data:'`",
                          "desc": "If you want to resolve `specifier` relative to a base URL, such as `import.meta.url`, you can pass that URL here. This property is ignored if the `parentURL` is supplied as the second argument."
                        },
                        {
                          "textRaw": "`data` {any} Any arbitrary, cloneable JavaScript value to pass into the [`initialize`][] hook.",
                          "name": "data",
                          "type": "any",
                          "desc": "Any arbitrary, cloneable JavaScript value to pass into the [`initialize`][] hook."
                        },
                        {
                          "textRaw": "`transferList` {Object\\[]} [transferable objects][] to be passed into the `initialize` hook.",
                          "name": "transferList",
                          "type": "Object\\[]",
                          "desc": "[transferable objects][] to be passed into the `initialize` hook."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>Register a module that exports <a href=\"#customization-hooks\">hooks</a> that customize Node.js module\nresolution and loading behavior. See <a href=\"#customization-hooks\">Customization hooks</a>.</p>\n<p>This feature requires <code>--allow-worker</code> if used with the <a href=\"permissions.html#permission-model\">Permission Model</a>.</p>"
            },
            {
              "textRaw": "`module.registerHooks(options)`",
              "type": "method",
              "name": "registerHooks",
              "meta": {
                "added": [
                  "v23.5.0"
                ],
                "changes": []
              },
              "stability": 1,
              "stabilityText": ".1 - Active development",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`load` {Function|undefined} See [load hook][]. **Default:** `undefined`.",
                          "name": "load",
                          "type": "Function|undefined",
                          "default": "`undefined`",
                          "desc": "See [load hook][]."
                        },
                        {
                          "textRaw": "`resolve` {Function|undefined} See [resolve hook][]. **Default:** `undefined`.",
                          "name": "resolve",
                          "type": "Function|undefined",
                          "default": "`undefined`",
                          "desc": "See [resolve hook][]."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>Register <a href=\"#customization-hooks\">hooks</a> that customize Node.js module resolution and loading behavior.\nSee <a href=\"#customization-hooks\">Customization hooks</a>.</p>"
            },
            {
              "textRaw": "`module.stripTypeScriptTypes(code[, options])`",
              "type": "method",
              "name": "stripTypeScriptTypes",
              "meta": {
                "added": [
                  "v23.2.0"
                ],
                "changes": []
              },
              "stability": 1,
              "stabilityText": ".1 - Active development",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {string} The code with type annotations stripped. `module.stripTypeScriptTypes()` removes type annotations from TypeScript code. It can be used to strip type annotations from TypeScript code before running it with `vm.runInContext()` or `vm.compileFunction()`. By default, it will throw an error if the code contains TypeScript features that require transformation such as `Enums`, see [type-stripping][] for more information. When mode is `'transform'`, it also transforms TypeScript features to JavaScript, see [transform TypeScript features][] for more information. When mode is `'strip'`, source maps are not generated, because locations are preserved. If `sourceMap` is provided, when mode is `'strip'`, an error will be thrown.",
                    "name": "return",
                    "type": "string",
                    "desc": "The code with type annotations stripped. `module.stripTypeScriptTypes()` removes type annotations from TypeScript code. It can be used to strip type annotations from TypeScript code before running it with `vm.runInContext()` or `vm.compileFunction()`. By default, it will throw an error if the code contains TypeScript features that require transformation such as `Enums`, see [type-stripping][] for more information. When mode is `'transform'`, it also transforms TypeScript features to JavaScript, see [transform TypeScript features][] for more information. When mode is `'strip'`, source maps are not generated, because locations are preserved. If `sourceMap` is provided, when mode is `'strip'`, an error will be thrown."
                  },
                  "params": [
                    {
                      "textRaw": "`code` {string} The code to strip type annotations from.",
                      "name": "code",
                      "type": "string",
                      "desc": "The code to strip type annotations from."
                    },
                    {
                      "textRaw": "`options` {Object}",
                      "name": "options",
                      "type": "Object",
                      "options": [
                        {
                          "textRaw": "`mode` {string} **Default:** `'strip'`. Possible values are:",
                          "name": "mode",
                          "type": "string",
                          "default": "`'strip'`. Possible values are:",
                          "options": [
                            {
                              "textRaw": "`'strip'` Only strip type annotations without performing the transformation of TypeScript features.",
                              "desc": "`'strip'` Only strip type annotations without performing the transformation of TypeScript features."
                            },
                            {
                              "textRaw": "`'transform'` Strip type annotations and transform TypeScript features to JavaScript.",
                              "desc": "`'transform'` Strip type annotations and transform TypeScript features to JavaScript."
                            }
                          ]
                        },
                        {
                          "textRaw": "`sourceMap` {boolean} **Default:** `false`. Only when `mode` is `'transform'`, if `true`, a source map will be generated for the transformed code.",
                          "name": "sourceMap",
                          "type": "boolean",
                          "default": "`false`. Only when `mode` is `'transform'`, if `true`, a source map will be generated for the transformed code"
                        },
                        {
                          "textRaw": "`sourceUrl` {string} Specifies the source url used in the source map.",
                          "name": "sourceUrl",
                          "type": "string",
                          "desc": "Specifies the source url used in the source map."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p><em>WARNING</em>: The output of this function should not be considered stable across Node.js versions,\ndue to changes in the TypeScript parser.</p>\n<pre><code class=\"language-mjs\">import { stripTypeScriptTypes } from 'node:module';\nconst code = 'const a: number = 1;';\nconst strippedCode = stripTypeScriptTypes(code);\nconsole.log(strippedCode);\n// Prints: const a         = 1;\n</code></pre>\n<pre><code class=\"language-cjs\">const { stripTypeScriptTypes } = require('node:module');\nconst code = 'const a: number = 1;';\nconst strippedCode = stripTypeScriptTypes(code);\nconsole.log(strippedCode);\n// Prints: const a         = 1;\n</code></pre>\n<p>If <code>sourceUrl</code> is provided, it will be used appended as a comment at the end of the output:</p>\n<pre><code class=\"language-mjs\">import { stripTypeScriptTypes } from 'node:module';\nconst code = 'const a: number = 1;';\nconst strippedCode = stripTypeScriptTypes(code, { mode: 'strip', sourceUrl: 'source.ts' });\nconsole.log(strippedCode);\n// Prints: const a         = 1\\n\\n//# sourceURL=source.ts;\n</code></pre>\n<pre><code class=\"language-cjs\">const { stripTypeScriptTypes } = require('node:module');\nconst code = 'const a: number = 1;';\nconst strippedCode = stripTypeScriptTypes(code, { mode: 'strip', sourceUrl: 'source.ts' });\nconsole.log(strippedCode);\n// Prints: const a         = 1\\n\\n//# sourceURL=source.ts;\n</code></pre>\n<p>When <code>mode</code> is <code>'transform'</code>, the code is transformed to JavaScript:</p>\n<pre><code class=\"language-mjs\">import { stripTypeScriptTypes } from 'node:module';\nconst code = `\n  namespace MathUtil {\n    export const add = (a: number, b: number) => a + b;\n  }`;\nconst strippedCode = stripTypeScriptTypes(code, { mode: 'transform', sourceMap: true });\nconsole.log(strippedCode);\n// Prints:\n// var MathUtil;\n// (function(MathUtil) {\n//     MathUtil.add = (a, b)=>a + b;\n// })(MathUtil || (MathUtil = {}));\n// # sourceMappingURL=data:application/json;base64, ...\n</code></pre>\n<pre><code class=\"language-cjs\">const { stripTypeScriptTypes } = require('node:module');\nconst code = `\n  namespace MathUtil {\n    export const add = (a: number, b: number) => a + b;\n  }`;\nconst strippedCode = stripTypeScriptTypes(code, { mode: 'transform', sourceMap: true });\nconsole.log(strippedCode);\n// Prints:\n// var MathUtil;\n// (function(MathUtil) {\n//     MathUtil.add = (a, b)=>a + b;\n// })(MathUtil || (MathUtil = {}));\n// # sourceMappingURL=data:application/json;base64, ...\n</code></pre>"
            },
            {
              "textRaw": "`module.syncBuiltinESMExports()`",
              "type": "method",
              "name": "syncBuiltinESMExports",
              "meta": {
                "added": [
                  "v12.12.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>The <code>module.syncBuiltinESMExports()</code> method updates all the live bindings for\nbuiltin <a href=\"esm.html\">ES Modules</a> to match the properties of the <a href=\"modules.html\">CommonJS</a> exports. It\ndoes not add or remove exported names from the <a href=\"esm.html\">ES Modules</a>.</p>\n<pre><code class=\"language-js\">const fs = require('node:fs');\nconst assert = require('node:assert');\nconst { syncBuiltinESMExports } = require('node:module');\n\nfs.readFile = newAPI;\n\ndelete fs.readFileSync;\n\nfunction newAPI() {\n  // ...\n}\n\nfs.newAPI = newAPI;\n\nsyncBuiltinESMExports();\n\nimport('node:fs').then((esmFS) => {\n  // It syncs the existing readFile property with the new value\n  assert.strictEqual(esmFS.readFile, newAPI);\n  // readFileSync has been deleted from the required fs\n  assert.strictEqual('readFileSync' in fs, false);\n  // syncBuiltinESMExports() does not remove readFileSync from esmFS\n  assert.strictEqual('readFileSync' in esmFS, true);\n  // syncBuiltinESMExports() does not add names\n  assert.strictEqual(esmFS.newAPI, undefined);\n});\n</code></pre>"
            }
          ],
          "type": "module",
          "displayName": "The `Module` object"
        },
        {
          "textRaw": "Module compile cache",
          "name": "module_compile_cache",
          "meta": {
            "added": [
              "v22.1.0"
            ],
            "changes": [
              {
                "version": "v22.8.0",
                "pr-url": "https://github.com/nodejs/node/pull/54501",
                "description": "add initial JavaScript APIs for runtime access."
              }
            ]
          },
          "desc": "<p>The module compile cache can be enabled either using the <a href=\"#moduleenablecompilecachecachedir\"><code>module.enableCompileCache()</code></a>\nmethod or the <a href=\"cli.html#node_compile_cachedir\"><code>NODE_COMPILE_CACHE=dir</code></a> environment variable. After it is enabled,\nwhenever Node.js compiles a CommonJS or a ECMAScript Module, it will use on-disk\n<a href=\"https://v8.dev/blog/code-caching-for-devs\">V8 code cache</a> persisted in the specified directory to speed up the compilation.\nThis may slow down the first load of a module graph, but subsequent loads of the same module\ngraph may get a significant speedup if the contents of the modules do not change.</p>\n<p>To clean up the generated compile cache on disk, simply remove the cache directory. The cache\ndirectory will be recreated the next time the same directory is used for for compile cache\nstorage. To avoid filling up the disk with stale cache, it is recommended to use a directory\nunder the <a href=\"os.html#ostmpdir\"><code>os.tmpdir()</code></a>. If the compile cache is enabled by a call to\n<a href=\"#moduleenablecompilecachecachedir\"><code>module.enableCompileCache()</code></a> without specifying the directory, Node.js will use\nthe <a href=\"cli.html#node_compile_cachedir\"><code>NODE_COMPILE_CACHE=dir</code></a> environment variable if it's set, or defaults\nto <code>path.join(os.tmpdir(), 'node-compile-cache')</code> otherwise. To locate the compile cache\ndirectory used by a running Node.js instance, use <a href=\"#modulegetcompilecachedir\"><code>module.getCompileCacheDir()</code></a>.</p>\n<p>Currently when using the compile cache with <a href=\"https://v8project.blogspot.com/2017/12/javascript-code-coverage.html\">V8 JavaScript code coverage</a>, the\ncoverage being collected by V8 may be less precise in functions that are\ndeserialized from the code cache. It's recommended to turn this off when\nrunning tests to generate precise coverage.</p>\n<p>The enabled module compile cache can be disabled by the <a href=\"cli.html#node_disable_compile_cache1\"><code>NODE_DISABLE_COMPILE_CACHE=1</code></a>\nenvironment variable. This can be useful when the compile cache leads to unexpected or\nundesired behaviors (e.g. less precise test coverage).</p>\n<p>Compilation cache generated by one version of Node.js can not be reused by a different\nversion of Node.js. Cache generated by different versions of Node.js will be stored\nseparately if the same base directory is used to persist the cache, so they can co-exist.</p>\n<p>At the moment, when the compile cache is enabled and a module is loaded afresh, the\ncode cache is generated from the compiled code immediately, but will only be written\nto disk when the Node.js instance is about to exit. This is subject to change. The\n<a href=\"#moduleflushcompilecache\"><code>module.flushCompileCache()</code></a> method can be used to ensure the accumulated code cache\nis flushed to disk in case the application wants to spawn other Node.js instances\nand let them share the cache long before the parent exits.</p>",
          "properties": [
            {
              "textRaw": "`module.constants.compileCacheStatus`",
              "name": "compileCacheStatus",
              "meta": {
                "added": [
                  "v22.8.0"
                ],
                "changes": []
              },
              "stability": 1,
              "stabilityText": ".1 - Active Development",
              "desc": "<p>The following constants are returned as the <code>status</code> field in the object returned by\n<a href=\"#moduleenablecompilecachecachedir\"><code>module.enableCompileCache()</code></a> to indicate the result of the attempt to enable the\n<a href=\"#module-compile-cache\">module compile cache</a>.</p>\n<table>\n  <tr>\n    <th>Constant</th>\n    <th>Description</th>\n  </tr>\n  <tr>\n    <td><code>ENABLED</code></td>\n    <td>\n      Node.js has enabled the compile cache successfully. The directory used to store the\n      compile cache will be returned in the <code>directory</code> field in the\n      returned object.\n    </td>\n  </tr>\n  <tr>\n    <td><code>ALREADY_ENABLED</code></td>\n    <td>\n      The compile cache has already been enabled before, either by a previous call to\n      <code>module.enableCompileCache()</code>, or by the <code>NODE_COMPILE_CACHE=dir</code>\n      environment variable. The directory used to store the\n      compile cache will be returned in the <code>directory</code> field in the\n      returned object.\n    </td>\n  </tr>\n  <tr>\n    <td><code>FAILED</code></td>\n    <td>\n      Node.js fails to enable the compile cache. This can be caused by the lack of\n      permission to use the specified directory, or various kinds of file system errors.\n      The detail of the failure will be returned in the <code>message</code> field in the\n      returned object.\n    </td>\n  </tr>\n  <tr>\n    <td><code>DISABLED</code></td>\n    <td>\n      Node.js cannot enable the compile cache because the environment variable\n      <code>NODE_DISABLE_COMPILE_CACHE=1</code> has been set.\n    </td>\n  </tr>\n</table>"
            }
          ],
          "methods": [
            {
              "textRaw": "`module.enableCompileCache([cacheDir])`",
              "type": "method",
              "name": "enableCompileCache",
              "meta": {
                "added": [
                  "v22.8.0"
                ],
                "changes": []
              },
              "stability": 1,
              "stabilityText": ".1 - Active Development",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object",
                    "options": [
                      {
                        "textRaw": "`status` {integer} One of the [`module.constants.compileCacheStatus`][]",
                        "name": "status",
                        "type": "integer",
                        "desc": "One of the [`module.constants.compileCacheStatus`][]"
                      },
                      {
                        "textRaw": "`message` {string|undefined} If Node.js cannot enable the compile cache, this contains the error message. Only set if `status` is `module.constants.compileCacheStatus.FAILED`.",
                        "name": "message",
                        "type": "string|undefined",
                        "desc": "If Node.js cannot enable the compile cache, this contains the error message. Only set if `status` is `module.constants.compileCacheStatus.FAILED`."
                      },
                      {
                        "textRaw": "`directory` {string|undefined} If the compile cache is enabled, this contains the directory where the compile cache is stored. Only set if `status` is `module.constants.compileCacheStatus.ENABLED` or `module.constants.compileCacheStatus.ALREADY_ENABLED`.",
                        "name": "directory",
                        "type": "string|undefined",
                        "desc": "If the compile cache is enabled, this contains the directory where the compile cache is stored. Only set if `status` is `module.constants.compileCacheStatus.ENABLED` or `module.constants.compileCacheStatus.ALREADY_ENABLED`."
                      }
                    ]
                  },
                  "params": [
                    {
                      "textRaw": "`cacheDir` {string|undefined} Optional path to specify the directory where the compile cache will be stored/retrieved.",
                      "name": "cacheDir",
                      "type": "string|undefined",
                      "desc": "Optional path to specify the directory where the compile cache will be stored/retrieved."
                    }
                  ]
                }
              ],
              "desc": "<p>Enable <a href=\"#module-compile-cache\">module compile cache</a> in the current Node.js instance.</p>\n<p>If <code>cacheDir</code> is not specified, Node.js will either use the directory specified by the\n<a href=\"cli.html#node_compile_cachedir\"><code>NODE_COMPILE_CACHE=dir</code></a> environment variable if it's set, or use\n<code>path.join(os.tmpdir(), 'node-compile-cache')</code> otherwise. For general use cases, it's\nrecommended to call <code>module.enableCompileCache()</code> without specifying the <code>cacheDir</code>,\nso that the directory can be overridden by the <code>NODE_COMPILE_CACHE</code> environment\nvariable when necessary.</p>\n<p>Since compile cache is supposed to be a quiet optimization that is not required for the\napplication to be functional, this method is designed to not throw any exception when the\ncompile cache cannot be enabled. Instead, it will return an object containing an error\nmessage in the <code>message</code> field to aid debugging.\nIf compile cache is enabled successfully, the <code>directory</code> field in the returned object\ncontains the path to the directory where the compile cache is stored. The <code>status</code>\nfield in the returned object would be one of the <code>module.constants.compileCacheStatus</code>\nvalues to indicate the result of the attempt to enable the <a href=\"#module-compile-cache\">module compile cache</a>.</p>\n<p>This method only affects the current Node.js instance. To enable it in child worker threads,\neither call this method in child worker threads too, or set the\n<code>process.env.NODE_COMPILE_CACHE</code> value to compile cache directory so the behavior can\nbe inherited into the child workers. The directory can be obtained either from the\n<code>directory</code> field returned by this method, or with <a href=\"#modulegetcompilecachedir\"><code>module.getCompileCacheDir()</code></a>.</p>"
            },
            {
              "textRaw": "`module.flushCompileCache()`",
              "type": "method",
              "name": "flushCompileCache",
              "meta": {
                "added": [
                  "v23.0.0"
                ],
                "changes": []
              },
              "stability": 1,
              "stabilityText": ".1 - Active Development",
              "signatures": [
                {
                  "params": []
                }
              ],
              "desc": "<p>Flush the <a href=\"#module-compile-cache\">module compile cache</a> accumulated from modules already loaded\nin the current Node.js instance to disk. This returns after all the flushing\nfile system operations come to an end, no matter they succeed or not. If there\nare any errors, this will fail silently, since compile cache misses should not\ninterfere with the actual operation of the application.</p>"
            },
            {
              "textRaw": "`module.getCompileCacheDir()`",
              "type": "method",
              "name": "getCompileCacheDir",
              "meta": {
                "added": [
                  "v22.8.0"
                ],
                "changes": []
              },
              "stability": 1,
              "stabilityText": ".1 - Active Development",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {string|undefined} Path to the [module compile cache][] directory if it is enabled, or `undefined` otherwise.",
                    "name": "return",
                    "type": "string|undefined",
                    "desc": "Path to the [module compile cache][] directory if it is enabled, or `undefined` otherwise."
                  },
                  "params": []
                }
              ],
              "desc": "<p><i id=\"module_customization_hooks\"></i></p>"
            }
          ],
          "type": "module",
          "displayName": "Module compile cache"
        },
        {
          "textRaw": "Source map v3 support",
          "name": "source_map_v3_support",
          "meta": {
            "added": [
              "v13.7.0",
              "v12.17.0"
            ],
            "changes": []
          },
          "stability": 1,
          "stabilityText": "Experimental",
          "desc": "<p>Helpers for interacting with the source map cache. This cache is\npopulated when source map parsing is enabled and\n<a href=\"https://sourcemaps.info/spec.html#h.lmz475t4mvbx\">source map include directives</a> are found in a modules' footer.</p>\n<p>To enable source map parsing, Node.js must be run with the flag\n<a href=\"cli.html#--enable-source-maps\"><code>--enable-source-maps</code></a>, or with code coverage enabled by setting\n<a href=\"cli.html#node_v8_coveragedir\"><code>NODE_V8_COVERAGE=dir</code></a>.</p>\n<pre><code class=\"language-mjs\">// module.mjs\n// In an ECMAScript module\nimport { findSourceMap, SourceMap } from 'node:module';\n</code></pre>\n<pre><code class=\"language-cjs\">// module.cjs\n// In a CommonJS module\nconst { findSourceMap, SourceMap } = require('node:module');\n</code></pre>",
          "methods": [
            {
              "textRaw": "`module.getSourceMapsSupport()`",
              "type": "method",
              "name": "getSourceMapsSupport",
              "meta": {
                "added": [
                  "v23.7.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object}",
                    "name": "return",
                    "type": "Object",
                    "options": [
                      {
                        "textRaw": "`enabled` {boolean} If the source maps support is enabled",
                        "name": "enabled",
                        "type": "boolean",
                        "desc": "If the source maps support is enabled"
                      },
                      {
                        "textRaw": "`nodeModules` {boolean} If the support is enabled for files in `node_modules`.",
                        "name": "nodeModules",
                        "type": "boolean",
                        "desc": "If the support is enabled for files in `node_modules`."
                      },
                      {
                        "textRaw": "`generatedCode` {boolean} If the support is enabled for generated code from `eval` or `new Function`.",
                        "name": "generatedCode",
                        "type": "boolean",
                        "desc": "If the support is enabled for generated code from `eval` or `new Function`."
                      }
                    ]
                  },
                  "params": []
                }
              ],
              "desc": "<p>This method returns whether the <a href=\"https://sourcemaps.info/spec.html\">Source Map v3</a> support for stack\ntraces is enabled.</p>\n<!-- Anchors to make sure old links find a target -->\n<p><a id=\"module_module_findsourcemap_path_error\"></a></p>"
            },
            {
              "textRaw": "`module.findSourceMap(path)`",
              "type": "method",
              "name": "findSourceMap",
              "meta": {
                "added": [
                  "v13.7.0",
                  "v12.17.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {module.SourceMap|undefined} Returns `module.SourceMap` if a source map is found, `undefined` otherwise.",
                    "name": "return",
                    "type": "module.SourceMap|undefined",
                    "desc": "Returns `module.SourceMap` if a source map is found, `undefined` otherwise."
                  },
                  "params": [
                    {
                      "textRaw": "`path` {string}",
                      "name": "path",
                      "type": "string"
                    }
                  ]
                }
              ],
              "desc": "<p><code>path</code> is the resolved path for the file for which a corresponding source map\nshould be fetched.</p>"
            },
            {
              "textRaw": "`module.setSourceMapsSupport(enabled[, options])`",
              "type": "method",
              "name": "setSourceMapsSupport",
              "meta": {
                "added": [
                  "v23.7.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`enabled` {boolean} Enable the source map support.",
                      "name": "enabled",
                      "type": "boolean",
                      "desc": "Enable the source map support."
                    },
                    {
                      "textRaw": "`options` {Object} Optional",
                      "name": "options",
                      "type": "Object",
                      "desc": "Optional",
                      "options": [
                        {
                          "textRaw": "`nodeModules` {boolean} If enabling the support for files in `node_modules`. **Default:** `false`.",
                          "name": "nodeModules",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "If enabling the support for files in `node_modules`."
                        },
                        {
                          "textRaw": "`generatedCode` {boolean} If enabling the support for generated code from `eval` or `new Function`. **Default:** `false`.",
                          "name": "generatedCode",
                          "type": "boolean",
                          "default": "`false`",
                          "desc": "If enabling the support for generated code from `eval` or `new Function`."
                        }
                      ]
                    }
                  ]
                }
              ],
              "desc": "<p>This function enables or disables the <a href=\"https://sourcemaps.info/spec.html\">Source Map v3</a> support for\nstack traces.</p>\n<p>It provides same features as launching Node.js process with commandline options\n<code>--enable-source-maps</code>, with additional options to alter the support for files\nin <code>node_modules</code> or generated codes.</p>\n<p>Only source maps in JavaScript files that are loaded after source maps has been\nenabled will be parsed and loaded. Preferably, use the commandline options\n<code>--enable-source-maps</code> to avoid losing track of source maps of modules loaded\nbefore this API call.</p>"
            }
          ],
          "classes": [
            {
              "textRaw": "Class: `module.SourceMap`",
              "type": "class",
              "name": "module.SourceMap",
              "meta": {
                "added": [
                  "v13.7.0",
                  "v12.17.0"
                ],
                "changes": []
              },
              "properties": [
                {
                  "textRaw": "`payload` Returns: {Object}",
                  "type": "Object",
                  "name": "return",
                  "desc": "<p>Getter for the payload used to construct the <a href=\"#class-modulesourcemap\"><code>SourceMap</code></a> instance.</p>"
                }
              ],
              "methods": [
                {
                  "textRaw": "`sourceMap.findEntry(lineOffset, columnOffset)`",
                  "type": "method",
                  "name": "findEntry",
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {Object}",
                        "name": "return",
                        "type": "Object"
                      },
                      "params": [
                        {
                          "textRaw": "`lineOffset` {number} The zero-indexed line number offset in the generated source",
                          "name": "lineOffset",
                          "type": "number",
                          "desc": "The zero-indexed line number offset in the generated source"
                        },
                        {
                          "textRaw": "`columnOffset` {number} The zero-indexed column number offset in the generated source",
                          "name": "columnOffset",
                          "type": "number",
                          "desc": "The zero-indexed column number offset in the generated source"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Given a line offset and column offset in the generated source\nfile, returns an object representing the SourceMap range in the\noriginal file if found, or an empty object if not.</p>\n<p>The object returned contains the following keys:</p>\n<ul>\n<li>generatedLine: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> The line offset of the start of the\nrange in the generated source</li>\n<li>generatedColumn: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> The column offset of start of the\nrange in the generated source</li>\n<li>originalSource: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> The file name of the original source,\nas reported in the SourceMap</li>\n<li>originalLine: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> The line offset of the start of the\nrange in the original source</li>\n<li>originalColumn: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> The column offset of start of the\nrange in the original source</li>\n<li>name: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a></li>\n</ul>\n<p>The returned value represents the raw range as it appears in the\nSourceMap, based on zero-indexed offsets, <em>not</em> 1-indexed line and\ncolumn numbers as they appear in Error messages and CallSite\nobjects.</p>\n<p>To get the corresponding 1-indexed line and column numbers from a\nlineNumber and columnNumber as they are reported by Error stacks\nand CallSite objects, use <code>sourceMap.findOrigin(lineNumber, columnNumber)</code></p>"
                },
                {
                  "textRaw": "`sourceMap.findOrigin(lineNumber, columnNumber)`",
                  "type": "method",
                  "name": "findOrigin",
                  "meta": {
                    "added": [
                      "v20.4.0",
                      "v18.18.0"
                    ],
                    "changes": []
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {Object}",
                        "name": "return",
                        "type": "Object"
                      },
                      "params": [
                        {
                          "textRaw": "`lineNumber` {number} The 1-indexed line number of the call site in the generated source",
                          "name": "lineNumber",
                          "type": "number",
                          "desc": "The 1-indexed line number of the call site in the generated source"
                        },
                        {
                          "textRaw": "`columnNumber` {number} The 1-indexed column number of the call site in the generated source",
                          "name": "columnNumber",
                          "type": "number",
                          "desc": "The 1-indexed column number of the call site in the generated source"
                        }
                      ]
                    }
                  ],
                  "desc": "<p>Given a 1-indexed <code>lineNumber</code> and <code>columnNumber</code> from a call site in\nthe generated source, find the corresponding call site location\nin the original source.</p>\n<p>If the <code>lineNumber</code> and <code>columnNumber</code> provided are not found in any\nsource map, then an empty object is returned. Otherwise, the\nreturned object contains the following keys:</p>\n<ul>\n<li>name: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type\" class=\"type\">&lt;undefined&gt;</a> The name of the range in the\nsource map, if one was provided</li>\n<li>fileName: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> The file name of the original source, as\nreported in the SourceMap</li>\n<li>lineNumber: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> The 1-indexed lineNumber of the\ncorresponding call site in the original source</li>\n<li>columnNumber: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a> The 1-indexed columnNumber of the\ncorresponding call site in the original source</li>\n</ul>"
                }
              ],
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`payload` {Object}",
                      "name": "payload",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`lineLengths` {number\\[]}",
                      "name": "lineLengths",
                      "type": "number\\[]"
                    }
                  ],
                  "desc": "<p>Creates a new <code>sourceMap</code> instance.</p>\n<p><code>payload</code> is an object with keys matching the <a href=\"https://sourcemaps.info/spec.html#h.mofvlxcwqzej\">Source map v3 format</a>:</p>\n<ul>\n<li><code>file</code>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a></li>\n<li><code>version</code>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type\" class=\"type\">&lt;number&gt;</a></li>\n<li><code>sources</code>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string[]&gt;</a></li>\n<li><code>sourcesContent</code>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string[]&gt;</a></li>\n<li><code>names</code>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string[]&gt;</a></li>\n<li><code>mappings</code>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a></li>\n<li><code>sourceRoot</code>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a></li>\n</ul>\n<p><code>lineLengths</code> is an optional array of the length of each line in the\ngenerated code.</p>"
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "Source map v3 support"
        }
      ],
      "stability": 1,
      "stabilityText": ".2 - Release candidate (asynchronous version) Stability: 1.1 - Active development (synchronous version)",
      "miscs": [
        {
          "textRaw": "Customization Hooks",
          "name": "Customization Hooks",
          "meta": {
            "added": [
              "v8.8.0"
            ],
            "changes": [
              {
                "version": "v23.5.0",
                "pr-url": "https://github.com/nodejs/node/pull/55698",
                "description": "Add support for synchronous and in-thread hooks."
              },
              {
                "version": [
                  "v20.6.0",
                  "v18.19.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/48842",
                "description": "Added `initialize` hook to replace `globalPreload`."
              },
              {
                "version": [
                  "v18.6.0",
                  "v16.17.0"
                ],
                "pr-url": "https://github.com/nodejs/node/pull/42623",
                "description": "Add support for chaining loaders."
              },
              {
                "version": "v16.12.0",
                "pr-url": "https://github.com/nodejs/node/pull/37468",
                "description": "Removed `getFormat`, `getSource`, `transformSource`, and `globalPreload`; added `load` hook and `getGlobalPreload` hook."
              }
            ]
          },
          "type": "misc",
          "stability": 1,
          "stabilityText": ".2 - Release candidate (asynchronous version) Stability: 1.1 - Active development (synchronous version)",
          "desc": "<p>There are two types of module customization hooks that are currently supported:</p>\n<ol>\n<li><code>module.register(specifier[, parentURL][, options])</code> which takes a module that\nexports asynchronous hook functions. The functions are run on a separate loader\nthread.</li>\n<li><code>module.registerHooks(options)</code> which takes synchronous hook functions that are\nrun directly on the thread where the module is loaded.</li>\n</ol>\n<p><i id=\"enabling_module_customization_hooks\"></i></p>",
          "miscs": [
            {
              "textRaw": "Enabling",
              "name": "enabling",
              "desc": "<p>Module resolution and loading can be customized by:</p>\n<ol>\n<li>Registering a file which exports a set of asynchronous hook functions, using the\n<a href=\"#moduleregisterspecifier-parenturl-options\"><code>register</code></a> method from <code>node:module</code>,</li>\n<li>Registering a set of synchronous hook functions using the <a href=\"#moduleregisterhooksoptions\"><code>registerHooks</code></a> method\nfrom <code>node:module</code>.</li>\n</ol>\n<p>The hooks can be registered before the application code is run by using the\n<a href=\"cli.html#--importmodule\"><code>--import</code></a> or <a href=\"cli.html#-r---require-module\"><code>--require</code></a> flag:</p>\n<pre><code class=\"language-bash\">node --import ./register-hooks.js ./my-app.js\nnode --require ./register-hooks.js ./my-app.js\n</code></pre>\n<pre><code class=\"language-mjs\">// register-hooks.js\n// This file can only be require()-ed if it doesn't contain top-level await.\n// Use module.register() to register asynchronous hooks in a dedicated thread.\nimport { register } from 'node:module';\nregister('./hooks.mjs', import.meta.url);\n</code></pre>\n<pre><code class=\"language-cjs\">// register-hooks.js\nconst { register } = require('node:module');\nconst { pathToFileURL } = require('node:url');\n// Use module.register() to register asynchronous hooks in a dedicated thread.\nregister('./hooks.mjs', pathToFileURL(__filename));\n</code></pre>\n<pre><code class=\"language-mjs\">// Use module.registerHooks() to register synchronous hooks in the main thread.\nimport { registerHooks } from 'node:module';\nregisterHooks({\n  resolve(specifier, context, nextResolve) { /* implementation */ },\n  load(url, context, nextLoad) { /* implementation */ },\n});\n</code></pre>\n<pre><code class=\"language-cjs\">// Use module.registerHooks() to register synchronous hooks in the main thread.\nconst { registerHooks } = require('node:module');\nregisterHooks({\n  resolve(specifier, context, nextResolve) { /* implementation */ },\n  load(url, context, nextLoad) { /* implementation */ },\n});\n</code></pre>\n<p>The file passed to <code>--import</code> or <code>--require</code> can also be an export from a dependency:</p>\n<pre><code class=\"language-bash\">node --import some-package/register ./my-app.js\nnode --require some-package/register ./my-app.js\n</code></pre>\n<p>Where <code>some-package</code> has an <a href=\"packages.html#exports\"><code>\"exports\"</code></a> field defining the <code>/register</code>\nexport to map to a file that calls <code>register()</code>, like the following <code>register-hooks.js</code>\nexample.</p>\n<p>Using <code>--import</code> or <code>--require</code> ensures that the hooks are registered before any\napplication files are imported, including the entry point of the application and for\nany worker threads by default as well.</p>\n<p>Alternatively, <code>register()</code> and <code>registerHooks()</code> can be called from the entry point,\nthough dynamic <code>import()</code> must be used for any ESM code that should be run after the hooks\nare registered.</p>\n<pre><code class=\"language-mjs\">import { register } from 'node:module';\n\nregister('http-to-https', import.meta.url);\n\n// Because this is a dynamic `import()`, the `http-to-https` hooks will run\n// to handle `./my-app.js` and any other files it imports or requires.\nawait import('./my-app.js');\n</code></pre>\n<pre><code class=\"language-cjs\">const { register } = require('node:module');\nconst { pathToFileURL } = require('node:url');\n\nregister('http-to-https', pathToFileURL(__filename));\n\n// Because this is a dynamic `import()`, the `http-to-https` hooks will run\n// to handle `./my-app.js` and any other files it imports or requires.\nimport('./my-app.js');\n</code></pre>\n<p>Customization hooks will run for any modules loaded later than the registration\nand the modules they reference via <code>import</code> and the built-in <code>require</code>.\n<code>require</code> function created by users using <code>module.createRequire()</code> can only be\ncustomized by the synchronous hooks.</p>\n<p>In this example, we are registering the <code>http-to-https</code> hooks, but they will\nonly be available for subsequently imported modules — in this case, <code>my-app.js</code>\nand anything it references via <code>import</code> or built-in <code>require</code> in CommonJS dependencies.</p>\n<p>If the <code>import('./my-app.js')</code> had instead been a static <code>import './my-app.js'</code>, the\napp would have <em>already</em> been loaded <strong>before</strong> the <code>http-to-https</code> hooks were\nregistered. This due to the ES modules specification, where static imports are\nevaluated from the leaves of the tree first, then back to the trunk. There can\nbe static imports <em>within</em> <code>my-app.js</code>, which will not be evaluated until\n<code>my-app.js</code> is dynamically imported.</p>\n<p>If synchronous hooks are used, both <code>import</code>, <code>require</code> and user <code>require</code> created\nusing <code>createRequire()</code> are supported.</p>\n<pre><code class=\"language-mjs\">import { registerHooks, createRequire } from 'node:module';\n\nregisterHooks({ /* implementation of synchronous hooks */ });\n\nconst require = createRequire(import.meta.url);\n\n// The synchronous hooks affect import, require() and user require() function\n// created through createRequire().\nawait import('./my-app.js');\nrequire('./my-app-2.js');\n</code></pre>\n<pre><code class=\"language-cjs\">const { register, registerHooks } = require('node:module');\nconst { pathToFileURL } = require('node:url');\n\nregisterHooks({ /* implementation of synchronous hooks */ });\n\nconst userRequire = createRequire(__filename);\n\n// The synchronous hooks affect import, require() and user require() function\n// created through createRequire().\nimport('./my-app.js');\nrequire('./my-app-2.js');\nuserRequire('./my-app-3.js');\n</code></pre>\n<p>Finally, if all you want to do is register hooks before your app runs and you\ndon't want to create a separate file for that purpose, you can pass a <code>data:</code>\nURL to <code>--import</code>:</p>\n<pre><code class=\"language-bash\">node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(\"http-to-https\", pathToFileURL(\"./\"));' ./my-app.js\n</code></pre>",
              "type": "misc",
              "displayName": "Enabling"
            },
            {
              "textRaw": "Chaining",
              "name": "chaining",
              "desc": "<p>It's possible to call <code>register</code> more than once:</p>\n<pre><code class=\"language-mjs\">// entrypoint.mjs\nimport { register } from 'node:module';\n\nregister('./foo.mjs', import.meta.url);\nregister('./bar.mjs', import.meta.url);\nawait import('./my-app.mjs');\n</code></pre>\n<pre><code class=\"language-cjs\">// entrypoint.cjs\nconst { register } = require('node:module');\nconst { pathToFileURL } = require('node:url');\n\nconst parentURL = pathToFileURL(__filename);\nregister('./foo.mjs', parentURL);\nregister('./bar.mjs', parentURL);\nimport('./my-app.mjs');\n</code></pre>\n<p>In this example, the registered hooks will form chains. These chains run\nlast-in, first out (LIFO). If both <code>foo.mjs</code> and <code>bar.mjs</code> define a <code>resolve</code>\nhook, they will be called like so (note the right-to-left):\nnode's default ← <code>./foo.mjs</code> ← <code>./bar.mjs</code>\n(starting with <code>./bar.mjs</code>, then <code>./foo.mjs</code>, then the Node.js default).\nThe same applies to all the other hooks.</p>\n<p>The registered hooks also affect <code>register</code> itself. In this example,\n<code>bar.mjs</code> will be resolved and loaded via the hooks registered by <code>foo.mjs</code>\n(because <code>foo</code>'s hooks will have already been added to the chain). This allows\nfor things like writing hooks in non-JavaScript languages, so long as\nearlier registered hooks transpile into JavaScript.</p>\n<p>The <code>register</code> method cannot be called from within the module that defines the\nhooks.</p>\n<p>Chaining of <code>registerHooks</code> work similarly. If synchronous and asynchronous\nhooks are mixed, the synchronous hooks are always run first before the asynchronous\nhooks start running, that is, in the last synchronous hook being run, its next\nhook includes invocation of the asynchronous hooks.</p>\n<pre><code class=\"language-mjs\">// entrypoint.mjs\nimport { registerHooks } from 'node:module';\n\nconst hook1 = { /* implementation of hooks */ };\nconst hook2 = { /* implementation of hooks */ };\n// hook2 run before hook1.\nregisterHooks(hook1);\nregisterHooks(hook2);\n</code></pre>\n<pre><code class=\"language-cjs\">// entrypoint.cjs\nconst { registerHooks } = require('node:module');\n\nconst hook1 = { /* implementation of hooks */ };\nconst hook2 = { /* implementation of hooks */ };\n// hook2 run before hook1.\nregisterHooks(hook1);\nregisterHooks(hook2);\n</code></pre>",
              "type": "misc",
              "displayName": "Chaining"
            },
            {
              "textRaw": "Communication with module customization hooks",
              "name": "communication_with_module_customization_hooks",
              "desc": "<p>Asynchronous hooks run on a dedicated thread, separate from the main\nthread that runs application code. This means mutating global variables won't\naffect the other thread(s), and message channels must be used to communicate\nbetween the threads.</p>\n<p>The <code>register</code> method can be used to pass data to an <a href=\"#initialize\"><code>initialize</code></a> hook. The\ndata passed to the hook may include transferable objects like ports.</p>\n<pre><code class=\"language-mjs\">import { register } from 'node:module';\nimport { MessageChannel } from 'node:worker_threads';\n\n// This example demonstrates how a message channel can be used to\n// communicate with the hooks, by sending `port2` to the hooks.\nconst { port1, port2 } = new MessageChannel();\n\nport1.on('message', (msg) => {\n  console.log(msg);\n});\nport1.unref();\n\nregister('./my-hooks.mjs', {\n  parentURL: import.meta.url,\n  data: { number: 1, port: port2 },\n  transferList: [port2],\n});\n</code></pre>\n<pre><code class=\"language-cjs\">const { register } = require('node:module');\nconst { pathToFileURL } = require('node:url');\nconst { MessageChannel } = require('node:worker_threads');\n\n// This example showcases how a message channel can be used to\n// communicate with the hooks, by sending `port2` to the hooks.\nconst { port1, port2 } = new MessageChannel();\n\nport1.on('message', (msg) => {\n  console.log(msg);\n});\nport1.unref();\n\nregister('./my-hooks.mjs', {\n  parentURL: pathToFileURL(__filename),\n  data: { number: 1, port: port2 },\n  transferList: [port2],\n});\n</code></pre>\n<p>Synchronous module hooks are run on the same thread where the application code is\nrun. They can directly mutate the globals of the context accessed by the main thread.</p>",
              "type": "misc",
              "displayName": "Communication with module customization hooks"
            },
            {
              "textRaw": "Hooks",
              "name": "hooks",
              "modules": [
                {
                  "textRaw": "Asynchronous hooks accepted by `module.register()`",
                  "name": "asynchronous_hooks_accepted_by_`module.register()`",
                  "desc": "<p>The <a href=\"#moduleregisterspecifier-parenturl-options\"><code>register</code></a> method can be used to register a module that exports a set of\nhooks. The hooks are functions that are called by Node.js to customize the\nmodule resolution and loading process. The exported functions must have specific\nnames and signatures, and they must be exported as named exports.</p>\n<pre><code class=\"language-mjs\">export async function initialize({ number, port }) {\n  // Receives data from `register`.\n}\n\nexport async function resolve(specifier, context, nextResolve) {\n  // Take an `import` or `require` specifier and resolve it to a URL.\n}\n\nexport async function load(url, context, nextLoad) {\n  // Take a resolved URL and return the source code to be evaluated.\n}\n</code></pre>\n<p>Asynchronous hooks are run in a separate thread, isolated from the main thread where\napplication code runs. That means it is a different <a href=\"https://tc39.es/ecma262/#realm\">realm</a>. The hooks thread\nmay be terminated by the main thread at any time, so do not depend on\nasynchronous operations (like <code>console.log</code>) to complete. They are inherited into\nchild workers by default.</p>",
                  "type": "module",
                  "displayName": "Asynchronous hooks accepted by `module.register()`"
                },
                {
                  "textRaw": "Synchronous hooks accepted by `module.registerHooks()`",
                  "name": "synchronous_hooks_accepted_by_`module.registerhooks()`",
                  "meta": {
                    "added": [
                      "v23.5.0"
                    ],
                    "changes": []
                  },
                  "stability": 1,
                  "stabilityText": ".1 - Active development",
                  "desc": "<p>The <code>module.registerHooks()</code> method accepts synchronous hook functions.\n<code>initialize()</code> is not supported nor necessary, as the hook implementer\ncan simply run the initialization code directly before the call to\n<code>module.registerHooks()</code>.</p>\n<pre><code class=\"language-mjs\">function resolve(specifier, context, nextResolve) {\n  // Take an `import` or `require` specifier and resolve it to a URL.\n}\n\nfunction load(url, context, nextLoad) {\n  // Take a resolved URL and return the source code to be evaluated.\n}\n</code></pre>\n<p>Synchronous hooks are run in the same thread and the same <a href=\"https://tc39.es/ecma262/#realm\">realm</a> where the modules\nare loaded. Unlike the asynchronous hooks they are not inherited into child worker\nthreads by default, though if the hooks are registered using a file preloaded by\n<a href=\"cli.html#--importmodule\"><code>--import</code></a> or <a href=\"cli.html#-r---require-module\"><code>--require</code></a>, child worker threads can inherit the preloaded scripts\nvia <code>process.execArgv</code> inheritance. See <a href=\"worker_threads.html#new-workerfilename-options\">the documentation of <code>Worker</code></a> for detail.</p>\n<p>In synchronous hooks, users can expect <code>console.log()</code> to complete in the same way that\nthey expect <code>console.log()</code> in module code to complete.</p>",
                  "type": "module",
                  "displayName": "Synchronous hooks accepted by `module.registerHooks()`"
                },
                {
                  "textRaw": "Conventions of hooks",
                  "name": "conventions_of_hooks",
                  "desc": "<p>Hooks are part of a <a href=\"#chaining\">chain</a>, even if that chain consists of only one\ncustom (user-provided) hook and the default hook, which is always present. Hook\nfunctions nest: each one must always return a plain object, and chaining happens\nas a result of each function calling <code>next&#x3C;hookName>()</code>, which is a reference to\nthe subsequent loader's hook (in LIFO order).</p>\n<p>A hook that returns a value lacking a required property triggers an exception. A\nhook that returns without calling <code>next&#x3C;hookName>()</code> <em>and</em> without returning\n<code>shortCircuit: true</code> also triggers an exception. These errors are to help\nprevent unintentional breaks in the chain. Return <code>shortCircuit: true</code> from a\nhook to signal that the chain is intentionally ending at your hook.</p>",
                  "type": "module",
                  "displayName": "Conventions of hooks"
                },
                {
                  "textRaw": "Import from HTTPS",
                  "name": "import_from_https",
                  "desc": "<p>The hook below registers hooks to enable rudimentary support for such\nspecifiers. While this may seem like a significant improvement to Node.js core\nfunctionality, there are substantial downsides to actually using these hooks:\nperformance is much slower than loading files from disk, there is no caching,\nand there is no security.</p>\n<pre><code class=\"language-mjs\">// https-hooks.mjs\nimport { get } from 'node:https';\n\nexport function load(url, context, nextLoad) {\n  // For JavaScript to be loaded over the network, we need to fetch and\n  // return it.\n  if (url.startsWith('https://')) {\n    return new Promise((resolve, reject) => {\n      get(url, (res) => {\n        let data = '';\n        res.setEncoding('utf8');\n        res.on('data', (chunk) => data += chunk);\n        res.on('end', () => resolve({\n          // This example assumes all network-provided JavaScript is ES module\n          // code.\n          format: 'module',\n          shortCircuit: true,\n          source: data,\n        }));\n      }).on('error', (err) => reject(err));\n    });\n  }\n\n  // Let Node.js handle all other URLs.\n  return nextLoad(url);\n}\n</code></pre>\n<pre><code class=\"language-mjs\">// main.mjs\nimport { VERSION } from 'https://coffeescript.org/browser-compiler-modern/coffeescript.js';\n\nconsole.log(VERSION);\n</code></pre>\n<p>With the preceding hooks module, running\n<code>node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(pathToFileURL(\"./https-hooks.mjs\"));' ./main.mjs</code>\nprints the current version of CoffeeScript per the module at the URL in\n<code>main.mjs</code>.</p>\n<!-- TODO(joyeecheung): add an example on how to implement it with a fetchSync based on\nworkers and Atomics.wait() - or all these examples are too much to be put in the API\ndocumentation already and should be put into a repository instead? -->",
                  "type": "module",
                  "displayName": "Import from HTTPS"
                },
                {
                  "textRaw": "Transpilation",
                  "name": "transpilation",
                  "desc": "<p>Sources that are in formats Node.js doesn't understand can be converted into\nJavaScript using the <a href=\"#loadurl-context-nextload\"><code>load</code> hook</a>.</p>\n<p>This is less performant than transpiling source files before running Node.js;\ntranspiler hooks should only be used for development and testing purposes.</p>",
                  "modules": [
                    {
                      "textRaw": "Asynchronous version",
                      "name": "asynchronous_version",
                      "desc": "<pre><code class=\"language-mjs\">// coffeescript-hooks.mjs\nimport { readFile } from 'node:fs/promises';\nimport { findPackageJSON } from 'node:module';\nimport coffeescript from 'coffeescript';\n\nconst extensionsRegex = /\\.(coffee|litcoffee|coffee\\.md)$/;\n\nexport async function load(url, context, nextLoad) {\n  if (extensionsRegex.test(url)) {\n    // CoffeeScript files can be either CommonJS or ES modules. Use a custom format\n    // to tell Node.js not to detect its module type.\n    const { source: rawSource } = await nextLoad(url, { ...context, format: 'coffee' });\n    // This hook converts CoffeeScript source code into JavaScript source code\n    // for all imported CoffeeScript files.\n    const transformedSource = coffeescript.compile(rawSource.toString(), url);\n\n    // To determine how Node.js would interpret the transpilation result,\n    // search up the file system for the nearest parent package.json file\n    // and read its \"type\" field.\n    return {\n      format: await getPackageType(url),\n      shortCircuit: true,\n      source: transformedSource,\n    };\n  }\n\n  // Let Node.js handle all other URLs.\n  return nextLoad(url, context);\n}\n\nasync function getPackageType(url) {\n  // `url` is only a file path during the first iteration when passed the\n  // resolved url from the load() hook\n  // an actual file path from load() will contain a file extension as it's\n  // required by the spec\n  // this simple truthy check for whether `url` contains a file extension will\n  // work for most projects but does not cover some edge-cases (such as\n  // extensionless files or a url ending in a trailing space)\n  const pJson = findPackageJSON(url);\n\n  return readFile(pJson, 'utf8')\n    .then(JSON.parse)\n    .then((json) => json?.type)\n    .catch(() => undefined);\n}\n</code></pre>",
                      "type": "module",
                      "displayName": "Asynchronous version"
                    },
                    {
                      "textRaw": "Synchronous version",
                      "name": "synchronous_version",
                      "desc": "<pre><code class=\"language-mjs\">// coffeescript-sync-hooks.mjs\nimport { readFileSync } from 'node:fs';\nimport { registerHooks, findPackageJSON } from 'node:module';\nimport coffeescript from 'coffeescript';\n\nconst extensionsRegex = /\\.(coffee|litcoffee|coffee\\.md)$/;\n\nfunction load(url, context, nextLoad) {\n  if (extensionsRegex.test(url)) {\n    const { source: rawSource } = nextLoad(url, { ...context, format: 'coffee' });\n    const transformedSource = coffeescript.compile(rawSource.toString(), url);\n\n    return {\n      format: getPackageType(url),\n      shortCircuit: true,\n      source: transformedSource,\n    };\n  }\n\n  return nextLoad(url, context);\n}\n\nfunction getPackageType(url) {\n  const pJson = findPackageJSON(url);\n  if (!pJson) {\n    return undefined;\n  }\n  try {\n    const file = readFileSync(pJson, 'utf-8');\n    return JSON.parse(file)?.type;\n  } catch {\n    return undefined;\n  }\n}\n\nregisterHooks({ load });\n</code></pre>",
                      "type": "module",
                      "displayName": "Synchronous version"
                    }
                  ],
                  "type": "module",
                  "displayName": "Transpilation"
                },
                {
                  "textRaw": "Running hooks",
                  "name": "running_hooks",
                  "desc": "<pre><code class=\"language-coffee\"># main.coffee\nimport { scream } from './scream.coffee'\nconsole.log scream 'hello, world'\n\nimport { version } from 'node:process'\nconsole.log \"Brought to you by Node.js version #{version}\"\n</code></pre>\n<pre><code class=\"language-coffee\"># scream.coffee\nexport scream = (str) -> str.toUpperCase()\n</code></pre>\n<p>For the sake of running the example, add a <code>package.json</code> file containing the\nmodule type of the CoffeeScript files.</p>\n<pre><code class=\"language-json\">{\n  \"type\": \"module\"\n}\n</code></pre>\n<p>This is only for running the example. In real world loaders, <code>getPackageType()</code> must be\nable to return an <code>format</code> known to Node.js even in the absence of an explicit type in a\n<code>package.json</code>, or otherwise the <code>nextLoad</code> call would throw <code>ERR_UNKNOWN_FILE_EXTENSION</code>\n(if undefined) or <code>ERR_UNKNOWN_MODULE_FORMAT</code> (if it's not a known format listed in\nthe <a href=\"#loadurl-context-nextload\">load hook</a> documentation).</p>\n<p>With the preceding hooks modules, running\n<code>node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(pathToFileURL(\"./coffeescript-hooks.mjs\"));' ./main.coffee</code>\nor <code>node --import ./coffeescript-sync-hooks.mjs ./main.coffee</code>\ncauses <code>main.coffee</code> to be turned into JavaScript after its source code is\nloaded from disk but before Node.js executes it; and so on for any <code>.coffee</code>,\n<code>.litcoffee</code> or <code>.coffee.md</code> files referenced via <code>import</code> statements of any\nloaded file.</p>",
                  "type": "module",
                  "displayName": "Running hooks"
                },
                {
                  "textRaw": "Import maps",
                  "name": "import_maps",
                  "desc": "<p>The previous two examples defined <code>load</code> hooks. This is an example of a\n<code>resolve</code> hook. This hooks module reads an <code>import-map.json</code> file that defines\nwhich specifiers to override to other URLs (this is a very simplistic\nimplementation of a small subset of the \"import maps\" specification).</p>",
                  "modules": [
                    {
                      "textRaw": "Asynchronous version",
                      "name": "asynchronous_version",
                      "desc": "<pre><code class=\"language-mjs\">// import-map-hooks.js\nimport fs from 'node:fs/promises';\n\nconst { imports } = JSON.parse(await fs.readFile('import-map.json'));\n\nexport async function resolve(specifier, context, nextResolve) {\n  if (Object.hasOwn(imports, specifier)) {\n    return nextResolve(imports[specifier], context);\n  }\n\n  return nextResolve(specifier, context);\n}\n</code></pre>",
                      "type": "module",
                      "displayName": "Asynchronous version"
                    },
                    {
                      "textRaw": "Synchronous version",
                      "name": "synchronous_version",
                      "desc": "<pre><code class=\"language-mjs\">// import-map-sync-hooks.js\nimport fs from 'node:fs/promises';\nimport module from 'node:module';\n\nconst { imports } = JSON.parse(fs.readFileSync('import-map.json', 'utf-8'));\n\nfunction resolve(specifier, context, nextResolve) {\n  if (Object.hasOwn(imports, specifier)) {\n    return nextResolve(imports[specifier], context);\n  }\n\n  return nextResolve(specifier, context);\n}\n\nmodule.registerHooks({ resolve });\n</code></pre>",
                      "type": "module",
                      "displayName": "Synchronous version"
                    },
                    {
                      "textRaw": "Using the hooks",
                      "name": "using_the_hooks",
                      "desc": "<p>With these files:</p>\n<pre><code class=\"language-mjs\">// main.js\nimport 'a-module';\n</code></pre>\n<pre><code class=\"language-json\">// import-map.json\n{\n  \"imports\": {\n    \"a-module\": \"./some-module.js\"\n  }\n}\n</code></pre>\n<pre><code class=\"language-mjs\">// some-module.js\nconsole.log('some module!');\n</code></pre>\n<p>Running <code>node --import 'data:text/javascript,import { register } from \"node:module\"; import { pathToFileURL } from \"node:url\"; register(pathToFileURL(\"./import-map-hooks.js\"));' main.js</code>\nor <code>node --import ./import-map-sync-hooks.js main.js</code>\nshould print <code>some module!</code>.</p>",
                      "type": "module",
                      "displayName": "Using the hooks"
                    }
                  ],
                  "type": "module",
                  "displayName": "Import maps"
                }
              ],
              "methods": [
                {
                  "textRaw": "`initialize()`",
                  "type": "method",
                  "name": "initialize",
                  "meta": {
                    "added": [
                      "v20.6.0",
                      "v18.19.0"
                    ],
                    "changes": []
                  },
                  "stability": 1,
                  "stabilityText": ".2 - Release candidate",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`data` {any} The data from `register(loader, import.meta.url, { data })`.",
                          "name": "data",
                          "type": "any",
                          "desc": "The data from `register(loader, import.meta.url, { data })`."
                        }
                      ]
                    }
                  ],
                  "desc": "<p>The <code>initialize</code> hook is only accepted by <a href=\"#moduleregisterspecifier-parenturl-options\"><code>register</code></a>. <code>registerHooks()</code> does\nnot support nor need it since initialization done for synchronous hooks can be run\ndirectly before the call to <code>registerHooks()</code>.</p>\n<p>The <code>initialize</code> hook provides a way to define a custom function that runs in\nthe hooks thread when the hooks module is initialized. Initialization happens\nwhen the hooks module is registered via <a href=\"#moduleregisterspecifier-parenturl-options\"><code>register</code></a>.</p>\n<p>This hook can receive data from a <a href=\"#moduleregisterspecifier-parenturl-options\"><code>register</code></a> invocation, including\nports and other transferable objects. The return value of <code>initialize</code> can be a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" class=\"type\">&lt;Promise&gt;</a>, in which case it will be awaited before the main application thread\nexecution resumes.</p>\n<p>Module customization code:</p>\n<pre><code class=\"language-mjs\">// path-to-my-hooks.js\n\nexport async function initialize({ number, port }) {\n  port.postMessage(`increment: ${number + 1}`);\n}\n</code></pre>\n<p>Caller code:</p>\n<pre><code class=\"language-mjs\">import assert from 'node:assert';\nimport { register } from 'node:module';\nimport { MessageChannel } from 'node:worker_threads';\n\n// This example showcases how a message channel can be used to communicate\n// between the main (application) thread and the hooks running on the hooks\n// thread, by sending `port2` to the `initialize` hook.\nconst { port1, port2 } = new MessageChannel();\n\nport1.on('message', (msg) => {\n  assert.strictEqual(msg, 'increment: 2');\n});\nport1.unref();\n\nregister('./path-to-my-hooks.js', {\n  parentURL: import.meta.url,\n  data: { number: 1, port: port2 },\n  transferList: [port2],\n});\n</code></pre>\n<pre><code class=\"language-cjs\">const assert = require('node:assert');\nconst { register } = require('node:module');\nconst { pathToFileURL } = require('node:url');\nconst { MessageChannel } = require('node:worker_threads');\n\n// This example showcases how a message channel can be used to communicate\n// between the main (application) thread and the hooks running on the hooks\n// thread, by sending `port2` to the `initialize` hook.\nconst { port1, port2 } = new MessageChannel();\n\nport1.on('message', (msg) => {\n  assert.strictEqual(msg, 'increment: 2');\n});\nport1.unref();\n\nregister('./path-to-my-hooks.js', {\n  parentURL: pathToFileURL(__filename),\n  data: { number: 1, port: port2 },\n  transferList: [port2],\n});\n</code></pre>"
                },
                {
                  "textRaw": "`resolve(specifier, context, nextResolve)`",
                  "type": "method",
                  "name": "resolve",
                  "meta": {
                    "changes": [
                      {
                        "version": "v23.5.0",
                        "pr-url": "https://github.com/nodejs/node/pull/55698",
                        "description": "Add support for synchronous and in-thread hooks."
                      },
                      {
                        "version": [
                          "v21.0.0",
                          "v20.10.0",
                          "v18.19.0"
                        ],
                        "pr-url": "https://github.com/nodejs/node/pull/50140",
                        "description": "The property `context.importAssertions` is replaced with `context.importAttributes`. Using the old name is still supported and will emit an experimental warning."
                      },
                      {
                        "version": [
                          "v18.6.0",
                          "v16.17.0"
                        ],
                        "pr-url": "https://github.com/nodejs/node/pull/42623",
                        "description": "Add support for chaining resolve hooks. Each hook must either call `nextResolve()` or include a `shortCircuit` property set to `true` in its return."
                      },
                      {
                        "version": [
                          "v17.1.0",
                          "v16.14.0"
                        ],
                        "pr-url": "https://github.com/nodejs/node/pull/40250",
                        "description": "Add support for import assertions."
                      }
                    ]
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {Object|Promise} The asynchronous version takes either an object containing the following properties, or a `Promise` that will resolve to such an object. The synchronous version only accepts an object returned synchronously.",
                        "name": "return",
                        "type": "Object|Promise",
                        "desc": "The asynchronous version takes either an object containing the following properties, or a `Promise` that will resolve to such an object. The synchronous version only accepts an object returned synchronously.",
                        "options": [
                          {
                            "textRaw": "`format` {string|null|undefined} A hint to the `load` hook (it might be ignored). It can be a module format (such as `'commonjs'` or `'module'`) or an arbitrary value like `'css'` or `'yaml'`.",
                            "name": "format",
                            "type": "string|null|undefined",
                            "desc": "A hint to the `load` hook (it might be ignored). It can be a module format (such as `'commonjs'` or `'module'`) or an arbitrary value like `'css'` or `'yaml'`."
                          },
                          {
                            "textRaw": "`importAttributes` {Object|undefined} The import attributes to use when caching the module (optional; if excluded the input will be used)",
                            "name": "importAttributes",
                            "type": "Object|undefined",
                            "desc": "The import attributes to use when caching the module (optional; if excluded the input will be used)"
                          },
                          {
                            "textRaw": "`shortCircuit` {undefined|boolean} A signal that this hook intends to terminate the chain of `resolve` hooks. **Default:** `false`",
                            "name": "shortCircuit",
                            "type": "undefined|boolean",
                            "default": "`false`",
                            "desc": "A signal that this hook intends to terminate the chain of `resolve` hooks."
                          },
                          {
                            "textRaw": "`url` {string} The absolute URL to which this input resolves",
                            "name": "url",
                            "type": "string",
                            "desc": "The absolute URL to which this input resolves"
                          }
                        ]
                      },
                      "params": [
                        {
                          "textRaw": "`specifier` {string}",
                          "name": "specifier",
                          "type": "string"
                        },
                        {
                          "textRaw": "`context` {Object}",
                          "name": "context",
                          "type": "Object",
                          "options": [
                            {
                              "textRaw": "`conditions` {string\\[]} Export conditions of the relevant `package.json`",
                              "name": "conditions",
                              "type": "string\\[]",
                              "desc": "Export conditions of the relevant `package.json`"
                            },
                            {
                              "textRaw": "`importAttributes` {Object} An object whose key-value pairs represent the attributes for the module to import",
                              "name": "importAttributes",
                              "type": "Object",
                              "desc": "An object whose key-value pairs represent the attributes for the module to import"
                            },
                            {
                              "textRaw": "`parentURL` {string|undefined} The module importing this one, or undefined if this is the Node.js entry point",
                              "name": "parentURL",
                              "type": "string|undefined",
                              "desc": "The module importing this one, or undefined if this is the Node.js entry point"
                            }
                          ]
                        },
                        {
                          "textRaw": "`nextResolve` {Function} The subsequent `resolve` hook in the chain, or the Node.js default `resolve` hook after the last user-supplied `resolve` hook",
                          "name": "nextResolve",
                          "type": "Function",
                          "desc": "The subsequent `resolve` hook in the chain, or the Node.js default `resolve` hook after the last user-supplied `resolve` hook",
                          "options": [
                            {
                              "textRaw": "`specifier` {string}",
                              "name": "specifier",
                              "type": "string"
                            },
                            {
                              "textRaw": "`context` {Object|undefined} When omitted, the defaults are provided. When provided, defaults are merged in with preference to the provided properties.",
                              "name": "context",
                              "type": "Object|undefined",
                              "desc": "When omitted, the defaults are provided. When provided, defaults are merged in with preference to the provided properties."
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "desc": "<blockquote>\n<p><strong>Warning</strong> In the case of the asynchronous version, despite support for returning\npromises and async functions, calls to <code>resolve</code> may still block the main thread which\ncan impact performance.</p>\n</blockquote>\n<p>The <code>resolve</code> hook chain is responsible for telling Node.js where to find and\nhow to cache a given <code>import</code> statement or expression, or <code>require</code> call. It can\noptionally return a format (such as <code>'module'</code>) as a hint to the <code>load</code> hook. If\na format is specified, the <code>load</code> hook is ultimately responsible for providing\nthe final <code>format</code> value (and it is free to ignore the hint provided by\n<code>resolve</code>); if <code>resolve</code> provides a <code>format</code>, a custom <code>load</code> hook is required\neven if only to pass the value to the Node.js default <code>load</code> hook.</p>\n<p>Import type attributes are part of the cache key for saving loaded modules into\nthe internal module cache. The <code>resolve</code> hook is responsible for returning an\n<code>importAttributes</code> object if the module should be cached with different\nattributes than were present in the source code.</p>\n<p>The <code>conditions</code> property in <code>context</code> is an array of conditions that will be used\nto match <a href=\"packages.html#conditional-exports\">package exports conditions</a> for this resolution\nrequest. They can be used for looking up conditional mappings elsewhere or to\nmodify the list when calling the default resolution logic.</p>\n<p>The current <a href=\"packages.html#conditional-exports\">package exports conditions</a> are always in\nthe <code>context.conditions</code> array passed into the hook. To guarantee <em>default\nNode.js module specifier resolution behavior</em> when calling <code>defaultResolve</code>, the\n<code>context.conditions</code> array passed to it <em>must</em> include <em>all</em> elements of the\n<code>context.conditions</code> array originally passed into the <code>resolve</code> hook.</p>\n<!-- TODO(joyeecheung): Math.random() is a bit too contrived. At least do a\nfind-and-replace mangling on the URLs. -->\n<pre><code class=\"language-mjs\">// Asynchronous version accepted by module.register().\nexport async function resolve(specifier, context, nextResolve) {\n  const { parentURL = null } = context;\n\n  if (Math.random() > 0.5) { // Some condition.\n    // For some or all specifiers, do some custom logic for resolving.\n    // Always return an object of the form {url: &#x3C;string>}.\n    return {\n      shortCircuit: true,\n      url: parentURL ?\n        new URL(specifier, parentURL).href :\n        new URL(specifier).href,\n    };\n  }\n\n  if (Math.random() &#x3C; 0.5) { // Another condition.\n    // When calling `defaultResolve`, the arguments can be modified. In this\n    // case it's adding another value for matching conditional exports.\n    return nextResolve(specifier, {\n      ...context,\n      conditions: [...context.conditions, 'another-condition'],\n    });\n  }\n\n  // Defer to the next hook in the chain, which would be the\n  // Node.js default resolve if this is the last user-specified loader.\n  return nextResolve(specifier);\n}\n</code></pre>\n<pre><code class=\"language-mjs\">// Synchronous version accepted by module.registerHooks().\nfunction resolve(specifier, context, nextResolve) {\n  // Similar to the asynchronous resolve() above, since that one does not have\n  // any asynchronous logic.\n}\n</code></pre>"
                },
                {
                  "textRaw": "`load(url, context, nextLoad)`",
                  "type": "method",
                  "name": "load",
                  "meta": {
                    "changes": [
                      {
                        "version": "v23.5.0",
                        "pr-url": "https://github.com/nodejs/node/pull/55698",
                        "description": "Add support for synchronous and in-thread version."
                      },
                      {
                        "version": "v20.6.0",
                        "pr-url": "https://github.com/nodejs/node/pull/47999",
                        "description": "Add support for `source` with format `commonjs`."
                      },
                      {
                        "version": [
                          "v18.6.0",
                          "v16.17.0"
                        ],
                        "pr-url": "https://github.com/nodejs/node/pull/42623",
                        "description": "Add support for chaining load hooks. Each hook must either call `nextLoad()` or include a `shortCircuit` property set to `true` in its return."
                      }
                    ]
                  },
                  "signatures": [
                    {
                      "return": {
                        "textRaw": "Returns: {Object|Promise} The asynchronous version takes either an object containing the following properties, or a `Promise` that will resolve to such an object. The synchronous version only accepts an object returned synchronously.",
                        "name": "return",
                        "type": "Object|Promise",
                        "desc": "The asynchronous version takes either an object containing the following properties, or a `Promise` that will resolve to such an object. The synchronous version only accepts an object returned synchronously.",
                        "options": [
                          {
                            "textRaw": "`format` {string}",
                            "name": "format",
                            "type": "string"
                          },
                          {
                            "textRaw": "`shortCircuit` {undefined|boolean} A signal that this hook intends to terminate the chain of `load` hooks. **Default:** `false`",
                            "name": "shortCircuit",
                            "type": "undefined|boolean",
                            "default": "`false`",
                            "desc": "A signal that this hook intends to terminate the chain of `load` hooks."
                          },
                          {
                            "textRaw": "`source` {string|ArrayBuffer|TypedArray} The source for Node.js to evaluate",
                            "name": "source",
                            "type": "string|ArrayBuffer|TypedArray",
                            "desc": "The source for Node.js to evaluate"
                          }
                        ]
                      },
                      "params": [
                        {
                          "textRaw": "`url` {string} The URL returned by the `resolve` chain",
                          "name": "url",
                          "type": "string",
                          "desc": "The URL returned by the `resolve` chain"
                        },
                        {
                          "textRaw": "`context` {Object}",
                          "name": "context",
                          "type": "Object",
                          "options": [
                            {
                              "textRaw": "`conditions` {string\\[]} Export conditions of the relevant `package.json`",
                              "name": "conditions",
                              "type": "string\\[]",
                              "desc": "Export conditions of the relevant `package.json`"
                            },
                            {
                              "textRaw": "`format` {string|null|undefined} The format optionally supplied by the `resolve` hook chain. This can be any string value as an input; input values do not need to conform to the list of acceptable return values described below.",
                              "name": "format",
                              "type": "string|null|undefined",
                              "desc": "The format optionally supplied by the `resolve` hook chain. This can be any string value as an input; input values do not need to conform to the list of acceptable return values described below."
                            },
                            {
                              "textRaw": "`importAttributes` {Object}",
                              "name": "importAttributes",
                              "type": "Object"
                            }
                          ]
                        },
                        {
                          "textRaw": "`nextLoad` {Function} The subsequent `load` hook in the chain, or the Node.js default `load` hook after the last user-supplied `load` hook",
                          "name": "nextLoad",
                          "type": "Function",
                          "desc": "The subsequent `load` hook in the chain, or the Node.js default `load` hook after the last user-supplied `load` hook",
                          "options": [
                            {
                              "textRaw": "`url` {string}",
                              "name": "url",
                              "type": "string"
                            },
                            {
                              "textRaw": "`context` {Object|undefined} When omitted, defaults are provided. When provided, defaults are merged in with preference to the provided properties. In the default `nextLoad`, if the module pointed to by `url` does not have explicit module type information, `context.format` is mandatory.",
                              "name": "context",
                              "type": "Object|undefined",
                              "desc": "When omitted, defaults are provided. When provided, defaults are merged in with preference to the provided properties. In the default `nextLoad`, if the module pointed to by `url` does not have explicit module type information, `context.format` is mandatory."
                            }
                          ]
                        }
                      ]
                    }
                  ],
                  "desc": "<p>The <code>load</code> hook provides a way to define a custom method of determining how a\nURL should be interpreted, retrieved, and parsed. It is also in charge of\nvalidating the import attributes.</p>\n<p>The final value of <code>format</code> must be one of the following:</p>\n<table>\n<thead>\n<tr>\n<th><code>format</code></th>\n<th>Description</th>\n<th>Acceptable types for <code>source</code> returned by <code>load</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'addon'</code></td>\n<td>Load a Node.js addon</td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type\" class=\"type\">&lt;null&gt;</a></td>\n</tr>\n<tr>\n<td><code>'builtin'</code></td>\n<td>Load a Node.js builtin module</td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type\" class=\"type\">&lt;null&gt;</a></td>\n</tr>\n<tr>\n<td><code>'commonjs'</code></td>\n<td>Load a Node.js CommonJS module</td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" class=\"type\">&lt;ArrayBuffer&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\" class=\"type\">&lt;TypedArray&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type\" class=\"type\">&lt;null&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type\" class=\"type\">&lt;undefined&gt;</a></td>\n</tr>\n<tr>\n<td><code>'json'</code></td>\n<td>Load a JSON file</td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" class=\"type\">&lt;ArrayBuffer&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\" class=\"type\">&lt;TypedArray&gt;</a></td>\n</tr>\n<tr>\n<td><code>'module'</code></td>\n<td>Load an ES module</td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\" class=\"type\">&lt;string&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" class=\"type\">&lt;ArrayBuffer&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\" class=\"type\">&lt;TypedArray&gt;</a></td>\n</tr>\n<tr>\n<td><code>'wasm'</code></td>\n<td>Load a WebAssembly module</td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" class=\"type\">&lt;ArrayBuffer&gt;</a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\" class=\"type\">&lt;TypedArray&gt;</a></td>\n</tr>\n</tbody>\n</table>\n<p>The value of <code>source</code> is ignored for type <code>'builtin'</code> because currently it is\nnot possible to replace the value of a Node.js builtin (core) module.</p>",
                  "modules": [
                    {
                      "textRaw": "Caveat in the asynchronous `load` hook",
                      "name": "caveat_in_the_asynchronous_`load`_hook",
                      "desc": "<p>When using the asynchronous <code>load</code> hook, omitting vs providing a <code>source</code> for\n<code>'commonjs'</code> has very different effects:</p>\n<ul>\n<li>When a <code>source</code> is provided, all <code>require</code> calls from this module will be\nprocessed by the ESM loader with registered <code>resolve</code> and <code>load</code> hooks; all\n<code>require.resolve</code> calls from this module will be processed by the ESM loader\nwith registered <code>resolve</code> hooks; only a subset of the CommonJS API will be\navailable (e.g. no <code>require.extensions</code>, no <code>require.cache</code>, no\n<code>require.resolve.paths</code>) and monkey-patching on the CommonJS module loader\nwill not apply.</li>\n<li>If <code>source</code> is undefined or <code>null</code>, it will be handled by the CommonJS module\nloader and <code>require</code>/<code>require.resolve</code> calls will not go through the\nregistered hooks. This behavior for nullish <code>source</code> is temporary — in the\nfuture, nullish <code>source</code> will not be supported.</li>\n</ul>\n<p>These caveats do not apply to the synchronous <code>load</code> hook, in which case\nthe complete set of CommonJS APIs available to the customized CommonJS\nmodules, and <code>require</code>/<code>require.resolve</code> always go through the registered\nhooks.</p>\n<p>The Node.js internal asynchronous <code>load</code> implementation, which is the value of <code>next</code> for the\nlast hook in the <code>load</code> chain, returns <code>null</code> for <code>source</code> when <code>format</code> is\n<code>'commonjs'</code> for backward compatibility. Here is an example hook that would\nopt-in to using the non-default behavior:</p>\n<pre><code class=\"language-mjs\">import { readFile } from 'node:fs/promises';\n\n// Asynchronous version accepted by module.register(). This fix is not needed\n// for the synchronous version accepted by module.registerHooks().\nexport async function load(url, context, nextLoad) {\n  const result = await nextLoad(url, context);\n  if (result.format === 'commonjs') {\n    result.source ??= await readFile(new URL(result.responseURL ?? url));\n  }\n  return result;\n}\n</code></pre>\n<p>This doesn't apply to the synchronous <code>load</code> hook either, in which case the\n<code>source</code> returned contains source code loaded by the next hook, regardless\nof module format.</p>\n<blockquote>\n<p><strong>Warning</strong>: The asynchronous <code>load</code> hook and namespaced exports from CommonJS\nmodules are incompatible. Attempting to use them together will result in an empty\nobject from the import. This may be addressed in the future. This does not apply\nto the synchronous <code>load</code> hook, in which case exports can be used as usual.</p>\n</blockquote>\n<blockquote>\n<p>These types all correspond to classes defined in ECMAScript.</p>\n</blockquote>\n<ul>\n<li>The specific <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" class=\"type\">&lt;ArrayBuffer&gt;</a> object is a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\" class=\"type\">&lt;SharedArrayBuffer&gt;</a>.</li>\n<li>The specific <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\" class=\"type\">&lt;TypedArray&gt;</a> object is a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\" class=\"type\">&lt;Uint8Array&gt;</a>.</li>\n</ul>\n<p>If the source value of a text-based format (i.e., <code>'json'</code>, <code>'module'</code>)\nis not a string, it is converted to a string using <a href=\"util.html#class-utiltextdecoder\"><code>util.TextDecoder</code></a>.</p>\n<p>The <code>load</code> hook provides a way to define a custom method for retrieving the\nsource code of a resolved URL. This would allow a loader to potentially avoid\nreading files from disk. It could also be used to map an unrecognized format to\na supported one, for example <code>yaml</code> to <code>module</code>.</p>\n<pre><code class=\"language-mjs\">// Asynchronous version accepted by module.register().\nexport async function load(url, context, nextLoad) {\n  const { format } = context;\n\n  if (Math.random() > 0.5) { // Some condition\n    /*\n      For some or all URLs, do some custom logic for retrieving the source.\n      Always return an object of the form {\n        format: &#x3C;string>,\n        source: &#x3C;string|buffer>,\n      }.\n    */\n    return {\n      format,\n      shortCircuit: true,\n      source: '...',\n    };\n  }\n\n  // Defer to the next hook in the chain.\n  return nextLoad(url);\n}\n</code></pre>\n<pre><code class=\"language-mjs\">// Synchronous version accepted by module.registerHooks().\nfunction load(url, context, nextLoad) {\n  // Similar to the asynchronous load() above, since that one does not have\n  // any asynchronous logic.\n}\n</code></pre>\n<p>In a more advanced scenario, this can also be used to transform an unsupported\nsource to a supported one (see <a href=\"#examples\">Examples</a> below).</p>\n<h3>Examples</h3>\n<p>The various module customization hooks can be used together to accomplish\nwide-ranging customizations of the Node.js code loading and evaluation\nbehaviors.</p>",
                      "type": "module",
                      "displayName": "Caveat in the asynchronous `load` hook"
                    }
                  ]
                }
              ],
              "type": "misc",
              "displayName": "Hooks"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Modules: `node:module` API"
    }
  ]
}