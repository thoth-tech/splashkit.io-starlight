---
title: Read a Button Press with SplashKit GPIO
description: Learn how to configure a Raspberry Pi GPIO pin as input and read a button press using SplashKit, with Local and Remote control options.
author: SplashKit Team
lastupdated: May 2025
---

import { Tabs, TabItem, Steps } from "@astrojs/starlight/components";

**{frontmatter.description}**  
Written by: {frontmatter.author}  
_Last updated: {frontmatter.lastupdated}_

---

:::caution[Before you begin:]
Handle wiring and power carefully. Always double‑check your pin connections and ensure your Raspberry Pi is powered down when building the circuit.
:::

This guide shows you how to **read a push‑button** connected to a Raspberry Pi GPIO pin using SplashKit. We’ll provide both **Local** (program runs on the Pi) and **Remote** (program runs elsewhere and talks to the Pi daemon) versions using **nested tabs**.

In SplashKit we use the **physical pin numbers** (e.g., `PIN_13`). A button is read by configuring a pin as **input** and polling its value in a loop.

## Components

- **Push‑button**
- **10 kΩ Resistor** (common for pull‑down/pull‑up circuits)
- **Jumper wires**
- **Breadboard**

### Example wiring (pull‑down)
- Connect one side of the button to **3.3V**.
- Connect the other side of the button to **GPIO Pin 13** (physical **PIN_13**).
- Add a **10 kΩ** resistor from **PIN_13** to **GND** (so the input reads LOW when not pressed).

> Your hardware may differ (e.g., pull‑up). If so, simply invert the logic in code.

## Starting the Daemon (needed for Remote mode)

:::tip[Daemons]
A daemon is a background process that runs continuously, waiting for requests to perform some action. For GPIO, SplashKit talks to the **pigpio** daemon on the Raspberry Pi.
:::

To check if the daemon is running on the Pi:
```shell
ps aux | grep pigpiod
```

If it isn’t running:
```shell
sudo pigpiod
```

:::note
The pigpio daemon listens on TCP port **8888** by default.  
Use a custom port with `sudo pigpiod -p <port>`. Ensure the port is reachable for Remote mode.  
See the remote access guide: https://programmers.guide/book/appendix/0-installation/4-0-remote-access-pi/
:::

Stop the daemon:
```shell
sudo killall pigpiod
```

## The Code

Below are complete programs that print the **button state** (“Pressed” / “Released”). We open a tiny window so SplashKit can process events; press any key to quit.

<Tabs syncKey="execution-mode">
<TabItem label="Local">

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
#include "splashkit.h"

int main()
{
    raspi_init();

    gpio_pin button_pin = PIN_13;
    raspi_set_mode(button_pin, GPIO_INPUT);

    open_window("dummy_window", 1, 1);
    while(!any_key_pressed())
    {
        process_events();

        gpio_pin_value v = raspi_read(button_pin);
        if (v == GPIO_HIGH)
            write_line("Pressed");
        else
            write_line("Released");

        delay(150); // debounce-ish delay
    }

    close_all_windows();
    raspi_cleanup();
    return 0;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
using SplashKitSDK;
using static SplashKitSDK.SplashKit;

RaspiInit();

GpioPin buttonPin = (GpioPin) 13;
RaspiSetMode(buttonPin, (GpioPinMode) 0); // 0 = Input

OpenWindow("dummy_window", 1, 1);
while(!AnyKeyPressed())
{
    ProcessEvents();

    var v = RaspiRead(buttonPin);
    if (v == (GpioPinValue)1)
        WriteLine("Pressed");
    else
        WriteLine("Released");

    Delay(150); // debounce-ish delay
}

CloseAllWindows();
RaspiCleanup();
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
using SplashKitSDK;

namespace RaspberryPiReadButton
{
    public class Program
    {
        public static void Main()
        {
            SplashKit.RaspiInit();

            GpioPin buttonPin = GpioPin.Pin13;
            SplashKit.RaspiSetMode(buttonPin, GpioPinMode.GpioInput);

            SplashKit.OpenWindow("dummy_window", 1, 1);
            while (!SplashKit.AnyKeyPressed())
            {
                SplashKit.ProcessEvents();

                var v = SplashKit.RaspiRead(buttonPin);
                if (v == GpioPinValue.GpioHigh)
                    SplashKit.WriteLine("Pressed");
                else
                    SplashKit.WriteLine("Released");

                SplashKit.Delay(150);
            }

            SplashKit.CloseAllWindows();
            SplashKit.RaspiCleanup();
        }
    }
}
```
</TabItem>
</Tabs>
</TabItem> <!-- end Local -->

<TabItem label="Remote">

:::note
**Remote mode requires the Raspberry Pi daemon** to be running on the target Pi.  
Default port: **8888** (override with `sudo pigpiod -p <port>`).  
Make sure the Pi’s IP/port is reachable from your computer.
:::

**How Remote works:**  
All remote functions have a `remote_` prefix.  
Except for `remote_raspi_init()`, every remote function takes the **connection object as the first parameter**, then the same parameters as the local version.

**`remote_raspi_init(name, ip, port)`**  
- **name**: a string label for this connection (can be retrieved via `connection_named()`)  
- **ip**: the Raspberry Pi’s IP address (get via `ifconfig` on the Pi)  
- **port**: pigpio daemon port (default **8888**)  
Returns: a **connection** object you must pass to all `remote_` GPIO calls.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
#include "splashkit.h"

int main()
{
    // Create a remote connection to the Pi named "pi1"
    connection conn = remote_raspi_init("pi1", "192.168.1.42", 8888);

    gpio_pin button_pin = PIN_13;
    remote_raspi_set_mode(conn, button_pin, GPIO_INPUT);

    open_window("dummy_window", 1, 1);
    while(!any_key_pressed())
    {
        process_events();

        gpio_pin_value v = remote_raspi_read(conn, button_pin);
        if (v == GPIO_HIGH)
            write_line("Pressed");
        else
            write_line("Released");

        delay(150);
    }

    close_all_windows();
    remote_raspi_cleanup(conn);
    return 0;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
using SplashKitSDK;
using static SplashKitSDK.SplashKit;

// Connect to the Pi named "pi1"
var conn = RemoteRaspiInit("pi1", "192.168.1.42", 8888);

GpioPin buttonPin = (GpioPin) 13;
RemoteRaspiSetMode(conn, buttonPin, (GpioPinMode) 0); // 0 = Input

OpenWindow("dummy_window", 1, 1);
while(!AnyKeyPressed())
{
    ProcessEvents();

    var v = RemoteRaspiRead(conn, buttonPin);
    if (v == (GpioPinValue)1)
        WriteLine("Pressed");
    else
        WriteLine("Released");

    Delay(150);
}

CloseAllWindows();
RemoteRaspiCleanup(conn);
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
using SplashKitSDK;

namespace RaspberryPiReadButton
{
    public class Program
    {
        public static void Main()
        {
            // Create a remote connection to the Pi named "pi1"
            var conn = SplashKit.RemoteRaspiInit("pi1", "192.168.1.42", 8888);

            GpioPin buttonPin = GpioPin.Pin13;
            SplashKit.RemoteRaspiSetMode(conn, buttonPin, GpioPinMode.GpioInput);

            SplashKit.OpenWindow("dummy_window", 1, 1);
            while (!SplashKit.AnyKeyPressed())
            {
                SplashKit.ProcessEvents();

                var v = SplashKit.RemoteRaspiRead(conn, buttonPin);
                if (v == GpioPinValue.GpioHigh)
                    SplashKit.WriteLine("Pressed");
                else
                    SplashKit.WriteLine("Released");

                SplashKit.Delay(150);
            }

            SplashKit.CloseAllWindows();
            SplashKit.RemoteRaspiCleanup(conn);
        }
    }
}
```
</TabItem>
</Tabs>
</TabItem> <!-- end Remote -->
</Tabs> <!-- end execution-mode -->

### Understanding the code

<Steps>

1. **Initialise / Connect**  
   - Local: `raspi_init()` / `RaspiInit()`  
   - Remote: `remote_raspi_init(name, ip, port)` returns a `connection` used in all `remote_` calls.

2. **Configure Pin Mode**  
   Set the button pin to **input**: `GPIO_INPUT` / `GpioPinMode.GpioInput`.

3. **Event Loop & Read**  
   We open a tiny window so SplashKit can process events. On each loop, read the pin value (`raspi_read` / `RemoteRaspiRead`).

4. **Cleanup**  
   Close the window and call `raspi_cleanup()` (or `remote_raspi_cleanup(conn)`).

</Steps>

### Build and run

<Tabs syncKey="code-language">
<TabItem label="C++">

```shell
g++ read_button.cpp -l SplashKit -o read_button
./read_button
```

</TabItem>
<TabItem label="C#">

```shell
dotnet build
dotnet run
```
</TabItem>
</Tabs>
