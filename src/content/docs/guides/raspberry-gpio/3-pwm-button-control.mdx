---
title: Control LED PWM with a Button using SplashKit GPIO
description: Use a push‑button to control LED brightness via PWM on Raspberry Pi with SplashKit. Includes Local and Remote versions.
author: SplashKit Team
lastupdated: May 2025
---

import { Tabs, TabItem, Steps } from "@astrojs/starlight/components";

**{frontmatter.description}**  
Written by: {frontmatter.author}  
_Last updated: {frontmatter.lastupdated}_

---

:::caution[Before you begin:]
Ensure your wiring matches the selected pin numbers. Always include a resistor for the LED.
:::

In this guide you’ll **read a button** and use it to **control LED brightness with PWM**.  
When the button is **released** the LED is dim; when the button is **pressed** the LED is bright.

We’ll provide **Local** and **Remote** examples using nested tabs.

## Components
- **LED** + resistor (220 Ω – 1 kΩ)  
- **Push‑button**  
- **10 kΩ** resistor (pull‑down example)  
- **Breadboard & jumper wires**

### Circuit (example pull‑down)
- LED anode → **PIN_12** (PWM‑capable), LED cathode → resistor → **GND**.  
- Button one side → **3.3V**.  
- Button other side → **PIN_13** (input) and via **10 kΩ** resistor → **GND**.

> If your wiring is pull‑up instead, invert the logic in code (HIGH=Released, LOW=Pressed).

## Starting the Daemon (for Remote)

```shell
sudo pigpiod
```

:::note
Default port: **8888**. Override with `sudo pigpiod -p <port>`. Ensure the port is reachable for Remote mode.  
Remote access guide: https://programmers.guide/book/appendix/0-installation/4-0-remote-access-pi/
:::

Stop:
```shell
sudo killall pigpiod
```

## The Code

When the button is pressed we set a higher PWM duty cycle (bright). When released we set a lower one (dim).

<Tabs syncKey="execution-mode">
<TabItem label="Local">

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
#include "splashkit.h"

int main()
{
    raspi_init();

    gpio_pin led_pin = PIN_12;   // PWM-capable LED
    gpio_pin btn_pin = PIN_13;   // Button input

    raspi_set_mode(btn_pin, GPIO_INPUT);

    open_window("dummy_window", 1, 1);
    while(!any_key_pressed())
    {
        process_events();

        gpio_pin_value v = raspi_read(btn_pin);
        if (v == GPIO_HIGH)
            raspi_pwm_write(led_pin, 90); // bright
        else
            raspi_pwm_write(led_pin, 20); // dim

        delay(50);
    }

    // turn LED off on exit
    raspi_pwm_write(led_pin, 0);
    close_all_windows();
    raspi_cleanup();
    return 0;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
using SplashKitSDK;
using static SplashKitSDK.SplashKit;

RaspiInit();

GpioPin ledPin = (GpioPin)12;   // PWM LED
GpioPin btnPin = (GpioPin)13;   // Button

RaspiSetMode(btnPin, (GpioPinMode)0); // Input

OpenWindow("dummy_window", 1, 1);
while(!AnyKeyPressed())
{
    ProcessEvents();

    var v = RaspiRead(btnPin);
    if (v == (GpioPinValue)1)
        RaspiPwmWrite(ledPin, 90); // bright
    else
        RaspiPwmWrite(ledPin, 20); // dim

    Delay(50);
}

// turn LED off on exit
RaspiPwmWrite(ledPin, 0);
CloseAllWindows();
RaspiCleanup();
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
using SplashKitSDK;

namespace RaspberryPiPwmButton
{
    public class Program
    {
        public static void Main()
        {
            SplashKit.RaspiInit();

            GpioPin ledPin = GpioPin.Pin12;
            GpioPin btnPin = GpioPin.Pin13;

            SplashKit.RaspiSetMode(btnPin, GpioPinMode.GpioInput);

            SplashKit.OpenWindow("dummy_window", 1, 1);
            while (!SplashKit.AnyKeyPressed())
            {
                SplashKit.ProcessEvents();

                var v = SplashKit.RaspiRead(btnPin);
                if (v == GpioPinValue.GpioHigh)
                    SplashKit.RaspiPwmWrite(ledPin, 90);
                else
                    SplashKit.RaspiPwmWrite(ledPin, 20);

                SplashKit.Delay(50);
            }

            SplashKit.RaspiPwmWrite(ledPin, 0);
            SplashKit.CloseAllWindows();
            SplashKit.RaspiCleanup();
        }
    }
}
```
</TabItem>
</Tabs>
</TabItem> <!-- end Local -->

<TabItem label="Remote">

:::note
**Remote mode requires the Raspberry Pi daemon** to be running on the target Pi.  
Default port: **8888**. You can override with `sudo pigpiod -p <port>`.
:::

**How Remote works:**  
Call `remote_raspi_init(name, ip, port)` → get a `connection` → pass to all `remote_` GPIO calls.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
#include "splashkit.h"

int main()
{
    connection conn = remote_raspi_init("pi1", "192.168.1.42", 8888);

    gpio_pin led_pin = PIN_12;
    gpio_pin btn_pin = PIN_13;

    remote_raspi_set_mode(conn, btn_pin, GPIO_INPUT);

    open_window("dummy_window", 1, 1);
    while(!any_key_pressed())
    {
        process_events();

        gpio_pin_value v = remote_raspi_read(conn, btn_pin);
        if (v == GPIO_HIGH)
            remote_raspi_pwm_write(conn, led_pin, 90);
        else
            remote_raspi_pwm_write(conn, led_pin, 20);

        delay(50);
    }

    remote_raspi_pwm_write(conn, led_pin, 0);
    close_all_windows();
    remote_raspi_cleanup(conn);
    return 0;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
using SplashKitSDK;
using static SplashKitSDK.SplashKit;

var conn = RemoteRaspiInit("pi1", "192.168.1.42", 8888);

GpioPin ledPin = (GpioPin)12;
GpioPin btnPin = (GpioPin)13;

RemoteRaspiSetMode(conn, btnPin, (GpioPinMode)0); // Input

OpenWindow("dummy_window", 1, 1);
while(!AnyKeyPressed())
{
    ProcessEvents();

    var v = RemoteRaspiRead(conn, btnPin);
    if (v == (GpioPinValue)1)
        RemoteRaspiPwmWrite(conn, ledPin, 90);
    else
        RemoteRaspiPwmWrite(conn, ledPin, 20);

    Delay(50);
}

RemoteRaspiPwmWrite(conn, ledPin, 0);
CloseAllWindows();
RemoteRaspiCleanup(conn);
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
using SplashKitSDK;

namespace RaspberryPiPwmButton
{
    public class Program
    {
        public static void Main()
        {
            var conn = SplashKit.RemoteRaspiInit("pi1", "192.168.1.42", 8888);

            GpioPin ledPin = GpioPin.Pin12;
            GpioPin btnPin = GpioPin.Pin13;

            SplashKit.RemoteRaspiSetMode(conn, btnPin, GpioPinMode.GpioInput);

            SplashKit.OpenWindow("dummy_window", 1, 1);
            while (!SplashKit.AnyKeyPressed())
            {
                SplashKit.ProcessEvents();

                var v = SplashKit.RemoteRaspiRead(conn, btnPin);
                if (v == GpioPinValue.GpioHigh)
                    SplashKit.RemoteRaspiPwmWrite(conn, ledPin, 90);
                else
                    SplashKit.RemoteRaspiPwmWrite(conn, ledPin, 20);

                SplashKit.Delay(50);
            }

            SplashKit.RemoteRaspiPwmWrite(conn, ledPin, 0);
            SplashKit.CloseAllWindows();
            SplashKit.RemoteRaspiCleanup(conn);
        }
    }
}
```
</TabItem>
</Tabs>
</TabItem> <!-- end Remote -->
</Tabs> <!-- end execution-mode -->

### Understanding the code

<Steps>

1. **Initialise / Connect**  
   - Local: `raspi_init()` / `RaspiInit()`  
   - Remote: `remote_raspi_init(name, ip, port)` returns `connection`.

2. **Configure Pin Modes**  
   - Button pin as **input** (`GPIO_INPUT`).  
   - LED pin uses **PWM** via `raspi_pwm_write` / `RemoteRaspiPwmWrite`.

3. **Loop**  
   - Read the button each frame.  
   - Choose a duty cycle (e.g., 90 bright, 20 dim).  
   - Add a small delay for stability and debounce.

4. **Cleanup**  
   - Turn the LED off, close the window, and cleanup GPIO (or `remote_raspi_cleanup(conn)`).

</Steps>

### Build and run

<Tabs syncKey="code-language">
<TabItem label="C++">

```shell
g++ pwm_button.cpp -l SplashKit -o pwm_button
./pwm_button
```

</TabItem>
<TabItem label="C#">

```shell
dotnet build
dotnet run
```
</TabItem>
</Tabs>
