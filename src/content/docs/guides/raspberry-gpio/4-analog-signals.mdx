---
title: Reading Analog Signals with ADC
description: Learn to read analog signals using SplashKit's ADC functionality to connect analog sensors to the Raspberry Pi
author: Ashen Tharuka
lastupdated: September 4 2025
sidebar:
  hidden: false
---

import { Tabs, TabItem } from "@astrojs/starlight/components";

**{frontmatter.description}**  
Written by: {frontmatter.author}  
_Last updated: {frontmatter.lastupdated}_

---

In previ      {
          WriteL      }
      ```csharp

    </Ta      ```cpp
      x = r      x = ReadAdc      x = SplashKit.ReadAdc(adc, 0) -      ```cpp
      close_adc(adc);
      raspi_cleanup();
      ```cpp

    </TabItem>ffset;
      y = SplashKit.ReadAdc(adc, 1) - axisOffset;
      ```csharp

    </TabItem>
    </Tabs>

    </TabItem>
    <TabItem label="Python">

      ```python
      x = read_adc(adc, 0) - axis_offset
      y = read_adc(adc, 1) - axis_offsetisOffset;
      y = ReadAdc(adc, 1) - axisOffset;
      ```csharp

    </TabItem>
    <TabItem label="Object-Oriented">

      ```csharp
      x = SplashKit.ReadAdc(adc, 0) - axisOffset;
      y = SplashKit.ReadAdc(adc, 1) - axisOffset;c, 0) - axis_offset;
      y = read_adc(adc, 1) - axis_offset;
      ```cpp

    </TabItem>
    <TabItem label="C#">

    <Tabs syncKey="csharp-style">
    <TabItem label="Top-level Statements">

      ```csharp
      x = ReadAdc(adc, 0) - axisOffset;
      y = ReadAdc(adc, 1) - axisOffset;
      ```csharpabs>

    </TabItem>
    <TabItem label="Python">

      ```python
      adc = open_adc("joystick_adc", AdcType.ads7830) to open ADC device!");
          return;
      }
      ```csharp

    </TabItem>
    <TabItem label="Object-Oriented">

      ```csharp
      AdcDevice adc = SplashKit.OpenAdc("joystick_adc", AdcType.Ads7830);ls we've covered reading and writing digital signals, and emulating analog signals through the use of Pulse-Width Modulation. In this tutorial we are reading analog signals using SplashKit's built-in ADC (Analog-to-Digital Converter) functionality. SplashKit now provides native support for I2C-based ADC devices, making it much easier to read analog values from sensors without manual SPI communication.

## Components

- Breadboard
- Jumper Wires

- Analog Sensor (e.g., Potentiometer or Joystick Module)

  For this tutorial, we'll use a simple potentiometer or joystick module that provides analog output. These devices output a varying voltage that corresponds to their position or state. A potentiometer provides a single analog channel, while a joystick typically provides two analog channels (X and Y axes) plus a digital button.

  ![KY-023 Joystick Image](./images/joystick_pinout.png)

- ADS7830 or PCF8591 I2C ADC Module

  SplashKit supports I2C-based ADC devices like the ADS7830 and PCF8591. These chips communicate via I2C protocol, making them easier to use than SPI-based alternatives. The ADS7830 is an 8-bit, 8-channel ADC, while the PCF8591 is an 8-bit, 4-channel ADC with additional DAC functionality.

  **ADS7830 Features:**
  - 8-bit resolution (0-255 values)
  - 8 analog input channels
  - I2C interface
  - Default address: 0x48

  **PCF8591 Features:**
  - 8-bit resolution (0-255 values)
  - 4 analog input channels
  - 1 analog output channel (DAC)
  - I2C interface
  - Default address: 0x48

  The wiring for I2C devices is much simpler than SPI:

  | ADC Pin | Raspberry Pi Pin |
  |---------|------------------|
  | VCC     | 3.3V             |
  | GND     | GND              |
  | SDA     | Pin 3 (SDA)      |
  | SCL     | Pin 5 (SCL)      |

  To communicate with these devices, we use I2C. I2C is a two-wire communication protocol that's simpler than SPI and allows multiple devices on the same bus. More information can be found at [I2C Communication Protocol](https://en.wikipedia.org/wiki/I%C2%B2C).

## The Circuit

The circuit for this tutorial is much simpler than the previous SPI-based approach. We connect the I2C ADC device to the Raspberry Pi's I2C pins, and connect our analog sensor to one of the ADC's input channels.

**Basic Connections:**

1. Connect the ADC module's VCC to Raspberry Pi 3.3V
2. Connect the ADC module's GND to Raspberry Pi GND  
3. Connect the ADC module's SDA to Raspberry Pi Pin 3 (SDA)
4. Connect the ADC module's SCL to Raspberry Pi Pin 5 (SCL)
5. Connect your analog sensor's output to ADC Channel 0
6. Connect your analog sensor's power and ground appropriately

**For a joystick module:**

- Connect VRx to ADC Channel 0
- Connect VRy to ADC Channel 1  
- Connect SW to Raspberry Pi Pin 29 (for digital button input)
- Connect joystick VCC to 3.3V and GND to ground

The I2C connection allows multiple devices on the same bus, making expansion easier than SPI-based solutions.

## The Code

:::caution[Before running the code.]
This code requires GPIO permissions. Make sure you run the program with appropriate permissions (usually `sudo`) or ensure your user is in the `gpio` group.
:::

With SplashKit's built-in ADC support, reading analog values becomes much simpler. We no longer need to manually handle SPI communication or bit manipulation.

<Tabs syncKey="code-language">
<TabItem label="C++">
  
  ```cpp
  #include "splashkit.h"

  using namespace std;

  int main()
  {
      const int button_read_interval = 100;
      unsigned long last_read = 0;
      const int axis_offset = 128; // For 8-bit ADC (0-255), center is around 128

      int num_presses = 0;
      int x = 0, y = 0;

      // Initialize Raspberry Pi GPIO
      raspi_init();
      
      // Set up digital button pin
      pins button_pin = PIN_29;
      raspi_set_mode(button_pin, GPIO_INPUT);
      raspi_set_pull_up_down(button_pin, PUD_UP);

      // Open ADC device (ADS7830 or PCF8591)
      adc_device adc = open_adc("joystick_adc", ADS7830);
      if (adc == nullptr) {
          write_line("Failed to open ADC device!");
          return -1;
      }

      // Create timer for button debouncing
      timer interval_timer = create_timer("read_interval");
      start_timer(interval_timer);

      // Create a minimal window for SplashKit event processing
      open_window("ADC Reader", 1, 1);
      
      while(!any_key_pressed())
      {
          process_events();
          unsigned long curr_time = timer_ticks(interval_timer);

          // Button reading with debouncing
          if(curr_time - last_read > button_read_interval)
          {
              last_read = curr_time;

              if(raspi_read(button_pin) == GPIO_LOW)
              {
                  num_presses++;
              }
          }

          // Read analog values from ADC channels
          x = read_adc(adc, 0) - axis_offset;
          y = read_adc(adc, 1) - axis_offset;

          // Clear screen and display values
          write("\033[2J\033[H");
          write("X: ");
          write(x);
          write(" Y: ");
          write_line(y);
          write("Button Presses: ");
          write_line(num_presses);

          delay(10); // Small delay to reduce CPU usage
      }

      // Cleanup
      close_all_windows();
      free_all_timers();
      close_adc(adc);
      raspi_cleanup();
      return 0;
  }
  ```cpp

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
using static SplashKitSDK.SplashKit;

const int buttonReadInterval = 100;
uint lastRead = 0;
const int axisOffset = 128; // For 8-bit ADC (0-255), center is around 128

int numPresses = 0;
int x = 0, y = 0;

// Initialize Raspberry Pi GPIO
RaspiInit();

// Set up digital button pin
Pins buttonPin = Pins.Pin29;
RaspiSetMode(buttonPin, PinModes.GpioInput);
RaspiSetPullUpDown(buttonPin, PullUpDown.PudUp);

// Open ADC device (ADS7830 or PCF8591)
AdcDevice adc = OpenAdc("joystick_adc", AdcType.Ads7830);
if (adc == null)
{
    WriteLine("Failed to open ADC device!");
    return;
}

// Create timer for button debouncing
Timer intervalTimer = CreateTimer("read_interval");
StartTimer(intervalTimer);

// Create a minimal window for SplashKit event processing
OpenWindow("ADC Reader", 1, 1);

while (!AnyKeyPressed())
{
    ProcessEvents();
    uint currTime = TimerTicks(intervalTimer);

    // Button reading with debouncing
    if (currTime - lastRead > buttonReadInterval)
    {
        lastRead = currTime;

        if (RaspiRead(buttonPin) == PinValues.GpioLow)
        {
            numPresses++;
        }
    }

    // Read analog values from ADC channels
    x = ReadAdc(adc, 0) - axisOffset;
    y = ReadAdc(adc, 1) - axisOffset;

    // Clear screen and display values
    Write("\u001b[2J\u001b[H");
    Write("X: ");
    Write(x);
    Write(" Y: ");
    WriteLine(y);
    Write("Button Presses: ");
    WriteLine(numPresses);

    Delay(10); // Small delay to reduce CPU usage
}

// Cleanup
CloseAllWindows();
FreeAllTimers();
CloseAdc(adc);
RaspiCleanup();
```csharp

</TabItem>
<TabItem label="Object-Oriented">

```csharpcsharp
using SplashKitSDK;

namespace AdcReaderApp
{
    public class Program
    {
        public static void Main()
        {
            const int buttonReadInterval = 100;
            uint lastRead = 0;
            const int axisOffset = 128; // For 8-bit ADC (0-255), center is around 128

            int numPresses = 0;
            int x = 0, y = 0;

            // Initialize Raspberry Pi GPIO
            SplashKit.RaspiInit();

            // Set up digital button pin
            Pins buttonPin = Pins.Pin29;
            SplashKit.RaspiSetMode(buttonPin, PinModes.GpioInput);
            SplashKit.RaspiSetPullUpDown(buttonPin, PullUpDown.PudUp);

            // Open ADC device (ADS7830 or PCF8591)
            AdcDevice adc = SplashKit.OpenAdc("joystick_adc", AdcType.Ads7830);
            if (adc == null)
            {
                SplashKit.WriteLine("Failed to open ADC device!");
                return;
            }

            // Create timer for button debouncing
            Timer intervalTimer = SplashKit.CreateTimer("read_interval");
            SplashKit.StartTimer(intervalTimer);

            // Create a minimal window for SplashKit event processing
            SplashKit.OpenWindow("ADC Reader", 1, 1);

            while (!SplashKit.AnyKeyPressed())
            {
                SplashKit.ProcessEvents();
                uint currTime = SplashKit.TimerTicks(intervalTimer);

                // Button reading with debouncing
                if (currTime - lastRead > buttonReadInterval)
                {
                    lastRead = currTime;

                    if (SplashKit.RaspiRead(buttonPin) == PinValues.GpioLow)
                    {
                        numPresses++;
                    }
                }

                // Read analog values from ADC channels
                x = SplashKit.ReadAdc(adc, 0) - axisOffset;
                y = SplashKit.ReadAdc(adc, 1) - axisOffset;

                // Clear screen and display values
                SplashKit.Write("\u001b[2J\u001b[H");
                SplashKit.Write("X: ");
                SplashKit.Write(x);
                SplashKit.Write(" Y: ");
                SplashKit.WriteLine(y);
                SplashKit.Write("Button Presses: ");
                SplashKit.WriteLine(numPresses);

                SplashKit.Delay(10); // Small delay to reduce CPU usage
            }

            // Cleanup
            SplashKit.CloseAllWindows();
            SplashKit.FreeAllTimers();
            SplashKit.CloseAdc(adc);
            SplashKit.RaspiCleanup();
        }
    }
}
```csharp

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
from splashkit import *

def main():
    button_read_interval = 100
    last_read = 0
    axis_offset = 128  # For 8-bit ADC (0-255), center is around 128

    num_presses = 0
    x = 0
    y = 0

    # Initialize Raspberry Pi GPIO
    raspi_init()

    # Set up digital button pin
    button_pin = Pins.pin_29
    raspi_set_mode(button_pin, PinModes.gpio_input)
    raspi_set_pull_up_down(button_pin, PullUpDown.pud_up)

    # Open ADC device (ADS7830 or PCF8591)
    adc = open_adc("joystick_adc", AdcType.ads7830)
    if adc is None:
        write_line("Failed to open ADC device!")
        return

    # Create timer for button debouncing
    interval_timer = create_timer("read_interval")
    start_timer(interval_timer)

    # Create a minimal window for SplashKit event processing
    open_window("ADC Reader", 1, 1)

    while not any_key_pressed():
        process_events()
        curr_time = timer_ticks(interval_timer)

        # Button reading with debouncing
        if curr_time - last_read > button_read_interval:
            last_read = curr_time

            if raspi_read(button_pin) == PinValues.gpio_low:
                num_presses += 1

        # Read analog values from ADC channels
        x = read_adc(adc, 0) - axis_offset
        y = read_adc(adc, 1) - axis_offset

        # Clear screen and display values
        write("\033[2J\033[H")
        write("X: ")
        write(x)
        write(" Y: ")
        write_line(y)
        write("Button Presses: ")
        write_line(num_presses)

        delay(10)  # Small delay to reduce CPU usage

    # Cleanup
    close_all_windows()
    free_all_timers()
    close_adc(adc)
    raspi_cleanup()

if __name__ == "__main__":
    main()
```python

</TabItem>
</Tabs>

The code above demonstrates how much simpler it is to work with ADC devices using SplashKit's built-in support. Let's break down the key improvements and how the code works.

### Key Improvements with SplashKit ADC

**Simplified Setup:**

- No manual SPI communication required
- No bit manipulation for control bytes
- Built-in device management

**Error Handling:**

- Automatic device detection and validation
- Clear error reporting if ADC device fails to open

**Cross-Language Support:**

- Consistent API across C++, C#, and Python
- Same functionality with language-appropriate naming conventions

### Code Breakdown

Let's examine the key parts of this implementation:

1. **ADC Device Initialization**

    <Tabs syncKey="code-language">
    <TabItem label="C++">

      ```cpp
      adc_device adc = open_adc("joystick_adc", ADS7830);
      if (adc == nullptr) {
          write_line("Failed to open ADC device!");
          return -1;
      }
      ```cpp

    </TabItem>
    <TabItem label="C#">

    <Tabs syncKey="csharp-style">
    <TabItem label="Top-level Statements">

      ```csharp
      AdcDevice adc = OpenAdc("joystick_adc", AdcType.Ads7830);
      if (adc == null)
      {
          WriteLine("Failed to open ADC device!");
          return;
      }
      ```

    </TabItem>
    <TabItem label="Object-Oriented">

      ```csharp
      AdcDevice adc = SplashKit.OpenAdc("joystick_adc", AdcType.Ads7830);
      if (adc == null)
      {
          SplashKit.WriteLine("Failed to open ADC device!");
          return;
      }
      ```

    </TabItem>
    </Tabs>

    </TabItem>
    <TabItem label="Python">

      ```python
      adc = open_adc("joystick_adc", AdcType.ads7830)
      if adc is None:
          write_line("Failed to open ADC device!")
          return
      ```python

    </TabItem>
    </Tabs>

    We open the ADC device with a name and specify the type. SplashKit handles all the I2C communication setup automatically. The function returns a device handle we can use for reading, or `null`/`nullptr`/`None` if the device couldn't be opened.

2. **Reading Analog Values**

    <Tabs syncKey="code-language">
    <TabItem label="C++">

      ```cpp
      x = read_adc(adc, 0) - axis_offset;
      y = read_adc(adc, 1) - axis_offset;
      ```

    </TabItem>
    <TabItem label="C#">

    <Tabs syncKey="csharp-style">
    <TabItem label="Top-level Statements">

      ```csharp
      x = ReadAdc(adc, 0) - axisOffset;
      y = ReadAdc(adc, 1) - axisOffset;
      ```

    </TabItem>
    <TabItem label="Object-Oriented">

      ```csharp
      x = SplashKit.ReadAdc(adc, 0) - axisOffset;
      y = SplashKit.ReadAdc(adc, 1) - axisOffset;
      ```

    </TabItem>
    </Tabs>

    </TabItem>
    <TabItem label="Python">

      ```python
      x = read_adc(adc, 0) - axis_offset
      y = read_adc(adc, 1) - axis_offset
      ```python

    </TabItem>
    </Tabs>

    Reading analog values is now a single function call. The `read_adc()` function returns an 8-bit value (0-255) representing the analog input. We subtract an offset to center the values around zero for joystick applications. The second parameter is the channel number (0-7 for ADS7830, 0-3 for PCF8591).

3. **Proper Cleanup**

    <Tabs syncKey="code-language">
    <TabItem label="C++">

      ```cpp
      close_adc(adc);
      raspi_cleanup();
      ```

    </TabItem>
    <TabItem label="C#">

    <Tabs syncKey="csharp-style">
    <TabItem label="Top-level Statements">

      ```csharp
      CloseAdc(adc);
      RaspiCleanup();
      ```

    </TabItem>
    <TabItem label="Object-Oriented">

      ```csharp
      SplashKit.CloseAdc(adc);
      SplashKit.RaspiCleanup();
      ```

    </TabItem>
    </Tabs>

    </TabItem>
    <TabItem label="Python">

      ```python
      close_adc(adc)
      raspi_cleanup()
      ```

    </TabItem>
    </Tabs>

    Always remember to close the ADC device when finished to free system resources.

### Expected Output

When you run this program, you should see output similar to:

```text
X: -15 Y: 23
Button Presses: 0
```

The values will change as you move the joystick or adjust your analog sensor. The range is approximately -128 to +127 for an 8-bit ADC centered around 128.

### Alternative ADC Devices

SplashKit supports multiple ADC types. You can easily switch between them by changing the ADC type parameter:

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
// For ADS7830 (8-channel, 8-bit)
adc_device adc = open_adc("my_adc", ADS7830);

// For PCF8591 (4-channel, 8-bit with DAC)
adc_device adc = open_adc("my_adc", PCF8591);
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
// For ADS7830 (8-channel, 8-bit)
AdcDevice adc = OpenAdc("my_adc", AdcType.Ads7830);

// For PCF8591 (4-channel, 8-bit with DAC)
AdcDevice adc = OpenAdc("my_adc", AdcType.Pcf8591);
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
// For ADS7830 (8-channel, 8-bit)
AdcDevice adc = SplashKit.OpenAdc("my_adc", AdcType.Ads7830);

// For PCF8591 (4-channel, 8-bit with DAC)
AdcDevice adc = SplashKit.OpenAdc("my_adc", AdcType.Pcf8591);
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
# For ADS7830 (8-channel, 8-bit)
adc = open_adc("my_adc", AdcType.ads7830)

# For PCF8591 (4-channel, 8-bit with DAC)
adc = open_adc("my_adc", AdcType.pcf8591)
```

</TabItem>
</Tabs>

### Further Information

#### Benefits of SplashKit's ADC Support

**Simplified Development:**

- No need to understand low-level communication protocols
- Automatic device detection and setup
- Consistent API across different ADC types
- Built-in error handling

**Improved Reliability:**

- Tested communication protocols
- Proper resource management
- Standardized device initialization

**Better Code Maintainability:**

- Less complex code to debug
- Cross-language compatibility
- Clear, readable function names

#### Supported ADC Devices

SplashKit currently supports several I2C-based ADC devices:

**ADS7830:**

- 8-bit resolution
- 8 single-ended channels
- I2C interface
- Popular for multi-sensor applications

**PCF8591:**

- 8-bit resolution
- 4 analog input channels
- 1 analog output channel (DAC)
- Good for basic analog I/O

#### Migration from SPI-based ADCs

If you're currently using SPI-based ADCs like the MCP3008, consider migrating to I2C-based solutions for the following benefits:

1. **Simpler Wiring:** Only 4 wires needed (VCC, GND, SDA, SCL)
2. **Multiple Devices:** Multiple I2C devices can share the same bus
3. **Built-in Support:** Native SplashKit functions handle all communication
4. **Better Integration:** Seamless integration with other SplashKit GPIO functions

#### Troubleshooting

**Device Not Found:**

- Check I2C wiring connections
- Verify device address (default 0x48 for most ADC devices)
- Ensure I2C is enabled on your Raspberry Pi (`sudo raspi-config`)

**Incorrect Readings:**

- Verify sensor connections to ADC channels
- Check power supply voltage (3.3V recommended)
- Ensure proper grounding

**Permission Issues:**

- Run program with `sudo` or add user to `gpio` group
- Check if I2C permissions are properly set
